[["index.html", "Gra w chaos Okładka", " Gra w chaos 2022-09-23 Okładka "],["jak-czytać-tę-książkę.html", "Jak czytać tę książkę?", " Jak czytać tę książkę? Fraktale to dziwaczne figury. Niby chaotyczne, ale opisane w zaskakująco uporządkowany sposób. Jednak aby dostrzec ten porządek, trzeba wiedzieć, na co patrzeć. Nasza podróż po krainie fraktali składa się z trzech części. Każda część ma swojego przewodnika, znakomitego polskiego matematyka, którego wyniki są związane z fraktalami. Pierwsza część skupiona jest głównie na konstrukcji trzech prostych fraktali. Uporządkujemy tutaj pewne kluczowe pojęcia niezbędne do zrozumienia dalszych rozdziałów. Przewodnikiem po niej jest genialny organizator – Wacław Sierpiński. Druga część pozwoli nam zagłębić się w matematyczne podstawy fraktali. Będą definicje i twierdzenia, z którymi zazwyczaj spotykają się studenci matematyki na pierwszym roku studiów. Kto mógłby lepiej zaopiekować się tą częścią niż genialny matematyk Stefan Banach? Trzeciej części patronuje Hugo Steinhaus, który bardzo interesował się zastosowaniami. Jest to więc wymarzony przewodnik po ciekawych zastosowaniach fraktali. Każda część zaczyna się od przedstawienia opiekuna, ponieważ matematyka to nie tylko wzory, ale też ludzie, którzy ją tworzą. O tej wymienionej powyżej trójce krążą legendy. Dlatego w każdej części znajduje się krótki komiks nawiązujący do ciekawego wydarzenia z ich życia. Następnie przedstawiona jest nowa metoda konstrukcji fraktali. Powinno to pobudzić apetyt matematyczny, który zaspokoić może wyłącznie formalne matematyczne przedstawienie, dlaczego dana metoda działa. Ostatni fragment każdej części to przykłady programów w językach R, Python i Julia pozwalające na odtworzenie omawianych fraktali. Na końcu książki znajduje się kieszonkowy atlas fraktali, z którymi zainteresowani czytelnicy mogą samodzielnie eksperymentować. Dlaczego fraktale? Ponad ćwierć wieku temu, kiedy byłem w drugiej klasie liceum, mój nauczyciel geometrii – profesor Wiesław Kostarczyk podrzucił mi książkę, która na nowo rozbudziła moje zainteresowanie matematyką. Były to Fraktale. Od geometrii do sztuki profesora Piotra Pierańskiego [Pier92]. Wtedy rozumiałem być może jedną piątą z tej książki, ale to wystarczyło, bym na lata zainteresował się tą tematyką. I co jakiś czas na nowo odkrywam związki z fraktalami w algorytmice, rachunku prawdopodobieństwa, topologii czy analizie funkcjonalnej. Kto wie, może, Drogi Czytelniku, ta książka rozbudzi też Twoje zainteresowanie tymi dziwacznymi obiektami. Podziękowania Ta książka nie powstałaby dzięki wielu osobom oraz instytucjom, które czasem pośrednio, a czasem bezpośrednio pomagało na rozmaitych etapach prac. Wszystkich wymienić nie sposób, ale muszę podziękować przynajmniej kilku osobom i instytucjom. Pierwsza wersja przykładowych kodów w językach Python i Julia powstała dzięki Krzysztofowi Trajkowskiemu, który wspiera mnie przy różnych inicjatywach od lat. Ilustracje w tej książce powstały dzięki Aleksandrowi Zawadzie, niesamowitemu projektantowi i grafikowi, który znalazł czas by uświetnić tę pozycje częścią komiksową z przygodami Bety i Bita. Ta książka jest jedną z trzech pozycji realizowanych przy wsparciu zadania ,,Komiksowa Matematyka’’ w projekcie MatFizChemPW — podnoszenie kompetencji matematyczno-przyrodniczych oraz ICT u młodzieży szkolonej. Projekt jest współfinansowany przez Unię Europejską ze środków Europejskiego Funduszu Społecznego w ramach Programu Wiedza Edukacja Rozwój 2014-2020. Bibliografia "],["witajcie-fraktale.html", "Rozdział 1 Witajcie, fraktale! 1.1 Wacław Sierpiński 1.2 Witajcie, fraktale! 1.3 Ale dlaczego to działa? 1.4 Przykłady w języku Python 1.5 Przykłady w języku R 1.6 Przykłady w języku Julia", " Rozdział 1 Witajcie, fraktale! Rozdział, w którym poznajemy badacza nieskończoności oraz po raz pierwszy rysujemy dywan składający się prawie z samych dziur. Beta i Bit spotykają Wacława Sierpińskiego podczas wykładu w Krakowie W bazgrołach znudzonego Bita Wacław Sierpiński dostrzegł arcyciekawą figurę 1.1 Wacław Sierpiński Okres dwudziestolecia międzywojennego to nie tylko odradzająca się Polska, to też czas bardzo intensywnego rozwoju polskiej szkoły matematycznej. Główne ośrodki rozwoju tej szkoły w okresie międzywojennym to Warszawa, Lwów i Kraków. Czołowi matematycy tego czasu często podróżowali pomiędzy tymi miastami, inspirując się, wymieniając wiedzą i doświadczeniem. A gdy mówimy o czołowych matematykach, to nie sposób nie wspomnieć o Wacławie Sierpińskim, który tytuł magistra uzyskał w Warszawie, doktora w Krakowie, a habilitację zrobił we Lwowie. Czy może być lepsza data urodzenia dla matematyka niż 14 marca? Właśnie w tym dniu w 1882 roku w Warszawie urodził się nasz bohater. Na studia trafił na Cesarski Uniwersytet Warszawski, gdzie pod opieką Gieorgija Woronoja (tak, to ten Woronoj od diagramu Woronoja) zainteresował się teorią liczb, obronił tytuł kandydata nauk (odpowiednik dzisiejszego magistra) i zaczął uczyć matematyki w gimnazjum. Nie pracował tam długo. Jako bardzo aktywna osoba, brał udział w strajkach szkolnych, przez co stracił pracę. Przeniósł się więc do Krakowa, a na Uniwersytecie Jagiellońskim szybko zrobił doktorat, badając sumy szeregów \\(\\sum_{m^2+n^2 \\leq x}f(m^2+n^2)\\). Trzy lata później habilitował się już na Uniwersytecie Lwowskim. W tamtym okresie i przez resztę życia wiele podróżował po znakomitych ośrodkach matematycznych na całym świecie, między innymi studiował w Getyndze, gdzie spotkał matematyka Constantina Carathéodory’ego (przez pewien czas pracującego w Breslau, dzisiejszym Wrocławiu) czy Hugona Steinhausa (o którym piszemy więcej w rozdziale trzecim). Był świetnym organizatorem, biorącym udział w wielu inicjatywach. Przykładowo w roku 1920 wspólnie z Zygmuntem Janiszewskim i Stefanem Mazurkiewiczem założyli ,,Fundamenta Mathematicae’’ – pierwsze na świecie czasopismo poświęcone logice matematycznej, teorii mnogości oraz ich zastosowaniom. Sierpiński szybko dał się poznać jako świetny i bardzo wszechstronny matematyk. Gdy w 1920 roku Jan Kowalewski tworzył oddział łamania sowieckich szyfrów, zatrudnił Wacława Sierpińskiego razem ze Stefanem Mazurkiewiczem i Stanisławem Leśniewskim, aby sprawniej odszyfrowywać sowieckie depesze. Oddział ten był na tyle efektywny, że później przypisywano mu znaczny wkład w sukces Wojska Polskiego podczas wojny polsko-bolszewickiej, w tym pamiętnej Bitwy Warszawskiej. Biuro Szyfrów w tamtych czasach było bardzo innowacyjnym przedsięwzięciem, dość powiedzieć, że powstało 20 lat przed sławnym Bletchley Park. Sprawny nasłuch radiowy, możliwy dzięki elektronikom z politechnik, połączony z efektywną analizą kryptograficzną, możliwą dzięki matematykom z Uniwersytetu Warszawskiego i Lwowskiego, dał dowódcom wojskowym niezbędne dane o planach wojsk wroga. Krążyły wręcz anegdoty, że Biuro Szyfrów było w stanie odszyfrować depesze szybciej niż planowani odbiorcy. Sukcesy tego zespołu zbudowały podwaliny pod Biuro Szyfrów w Poznaniu, które dekadę później rozsławili łamacze Enigmy: Marian Rejewski, Jerzy Różycki i Henryk Zygalski. Przez lata Wacław Sierpiński uczył studentów w gimnazjach, wykładał na uniwersytetach, ale też pisał podręczniki. Wielu wydań doczekał się bardzo znany podręcznik do arytmetyki i geometrii, który napisał razem ze Stefanem Banachem i Włodzimierzem Stożkiem. Z uwagi na działalność związaną z nauczaniem został prezesem Towarzystwa Nauczycieli Szkół Średnich i Wyższych. Był też promotorem doktoratów wielu wybitnych matematyków, np. Jerzego Spławy-Neymana, Ottona Nikodyma, Kazimierza Kuratowskiego czy Alfreda Tarskiego. Sierpiński miał zatem liczne talenty, ale jego zainteresowania były głównie związane z prowadzeniem badań naukowych. Napisał łącznie 113 artykułów, nie sposób więc krótko streścić jego licznych wyników. Jego pasją było studiowanie nieskończoności, czy to w teorii liczb, analizie matematycznej, teorii mnogości, czy topologii. W roku 1915, w wieku 33 lat, podał sposób konstrukcji ciekawej figury, nazywanej później trójkątem Sierpińskiego. Powstaje ona jako wynik nieskończonego ciągu pewnych operacji. Jest to dziś jeden z najpopularniejszych fraktali, choć słowo pojęcie fraktala wprowadził dopiero Benedykt Mandelbrot 60 lat później, w roku 1975. Jego nagrobek można znaleźć na warszawskich Powązkach, a na nagrobku widnieje napis ,,Badacz nieskończoności’’. 1.2 Witajcie, fraktale! To fascynujące, że powtarzanie w nieskończoność tych samych czynności może prowadzić do powstania arcyciekawych figur – fraktali. Taką figurę może narysować każdy, wystarczy podstawowa znajomość programowania. Krok po kroku pokażemy, jak skonstruować różne klasy fraktali. Znajomość podstaw algebry, prawdopodobieństwa lub topologii pozwala dokładniej zrozumieć, skąd się te zaskakujące figury biorą. 1.2.1 Kurz Cantora Jedną z ciekawszych metod konstrukcji fraktali jest metoda ,,przez wygryzanie’’. Bierzemy pewną figurę, a następnie usuwamy z niej (wygryzamy) kawałki. To, co zostaje, jest fraktalem, często o zaskakujących właściwościach. Zilustrujmy to na przykładzie fraktala nazywanego kurzem Cantora (od nazwiska Georga Cantora, pioniera teorii mnogości). Receptura na konstrukcję kurzu Cantora. Weź odcinek o dowolnej długości (ale dla uproszczenia nasz będzie miał długość 1). Podziel ten odcinek na trzy równe części. Usuń wnętrze środkowej części, przez co otrzymasz dwa odcinki, oba o długości 1/3 wyjściowego odcinka. Dla każdego z otrzymanych odcinków kontynuuj dzielenie, idąc do kroku 2. Ilustracja pięciu kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 1. Rysunek 1: Pierwsze 5 iteracji w konstrukcji kurzu Cantora Powyższy algorytm cechuje kilka elementów typowych dla fraktali. Po pierwsze, nigdy się nie kończy, całą procedurę należy (przynajmniej w teorii) powtarzać nieskończenie wiele razy. Po drugie, mamy do czynienia z rekurencją. Trzeci krok prowadzi do powstania zbioru dwóch obiektów, a następnie każdy z nich jest ponownie przekształcany w taki sam sposób jak obiekt wyjściowy. Postępując bardzo podobnie, można otrzymać wiele ciekawych figur, ale przyjrzyjmy się jeszcze przez chwilę kurzowi Cantora. Zobaczmy, co my właściwie otrzymaliśmy w wyniku tej procedury. Sprawdźmy może, jak duży jest ten obiekt, czyli jaką ma długość. Początkowo odcinek miał długość \\(1\\), ale w pierwszym kroku usunęliśmy \\(1/3\\). W drugim kroku usunęliśmy \\(2\\) razy po \\((1/3)^2\\). Powtarzając to kilkukrotnie, w kroku \\(k\\) usuwamy \\(2^{k-1}\\) odcinków, każdy o długości \\((1/3)^k\\). A więc długość tego tworu w kroku \\(k\\) to: \\[\\begin{equation} \\begin{split} 1 &amp;- 1/3 - 2*(1/3)^2 - ... - 2^{k-1}*(1/3)^k = \\\\ &amp; 1 - \\sum_{i=1}^k 2^{i-1}*(1/3)^i = 1 - 1/2 \\sum_{i=1}^k (2/3)^i = \\\\ &amp; 1 - \\frac 12 (2 - 2 (2/3^k)) = (2/3)^k \\xrightarrow[k\\rightarrow \\infty]{} 0 \\end{split} \\end{equation}\\] Do tego samego wniosku można dojść, stosując inne rozumowanie, a mianowicie patrząc, ile zostało z odcinka po \\(k\\)-tym kroku. Po pierwszym kroku mamy \\(2\\) odcinki długości \\(1/3\\), po drugim kroku mamy \\(2^2\\) odcinków długości \\((1/3)^2\\), a po kroku \\(k\\) mamy \\(2^k\\) odcinków o długości \\((1/3)^k\\). Do czego zbiega ten ciąg? \\[ \\lim_{k \\rightarrow \\infty} (2/3)^k = 0 \\] Nie ma więc wątpliwości. Zbiór Cantora ma długość równą \\(0\\). Ale ewidentnie nie jest zbiorem pustym, bo ma wiele punktów. Jak wiele? Okazuje się, że tyle samo co cały odcinek, a więc nieprzeliczalnie wiele. Pokażmy to za pomocą pewnego sprytnego dowodu. Twierdzenie (liczność zbioru Cantora). Zbiór Cantora jest równoliczny z odcinkiem \\([0, 1]\\). Dowód: Aby policzyć punkty w zbiorze Cantora, musimy dla każdego punktu skonstruować rodowód, a więc zapis pozwalający jednoznacznie zidentyfikować każdy punkt. Rodowodem jednoznacznie identyfikującym punkt nazwiemy zbiór decyzji określających, jak do tego punktu dotrzeć w kolejnych krokach procedury generującej kurz Cantora. Pamiętamy, że w każdym kroku usuwane są środki z odcinków, więc punkt, który należy do kurzu Cantora, będzie leżał albo w lewym albo w prawym odcinku. Ten wybór (lewy/prawy) trzeba podjąć w każdym kroku konstrukcji kurzu. Taki rodowód możemy zapisać przez nieskończoną sekwencję cyfr 0/1 – jeżeli w sekwencji na pozycji \\(k\\) występuje 0, to punkt należy do lewego pododcinka, jeżeli 1, to do prawego. Zauważmy jednoznaczność -&gt; każdy punkt z kurzu Cantora może być opisany przez nieskończoną sekwencję cyfr 0/1. Jednocześnie każda nieskończona sekwencja cyfr opisuje jakiś punkt ze zbioru Cantora, a różne sekwencje opisują różne punkty. Ile jest takich sekwencji? Tyle samo co w całym odcinku. Wystarczy bowiem myśleć o tych sekwencjach jak o rozwinięciach dwójkowych liczb z przedziału \\([0, 1]\\). ∎ Co więc mamy? Kurz Cantora ma tyle samo punktów co odcinek \\([0, 1]\\). Ale jednocześnie ma długość 0, choć odcinek ma oczywiście długość 1. Jak to możliwe? To jedna z wielu zagadek kryjących się w krainie fraktali malowanych nieskończonością. 1.2.2 Trójkąt Sierpińskiego Jeden z najbardziej znanych fraktali to z pewnością trójkąt Sierpińskiego, którego konstrukcja jest dosyć podobna do metody tworzenia kurzu Cantora. Receptura na konstrukcję trójkąta Sierpińskiego. Weź trójkąt równoboczny o dowolnej wielkości. Podziel ten trójkąt na cztery trójkąty równoboczne. Usuń wnętrze środkowego trójkąta, przez co otrzymasz trzy trójkąty z brzegiem, wszystkie o wielkości boku 1/2 wyjściowego trójkąta. Dla każdego z trzech otrzymanych trójkątów kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 2. Rysunek 2: Pierwsze cztery iteracje w konstrukcji trójkąta Sierpińskiego 1.3 Ale dlaczego to działa? Ładny to twór. Ale jakie ma właściwości? Jakie ma pole? Szybkie rachunki pozwalają rozwiać wszelkie wątpliwości. W kroku \\(k\\) trójkąt składa się z \\(3^k\\) trójkątów, każdy o boku \\(1/2^k\\), czyli polu \\(\\sqrt{3}/2^{2k+1}\\). Łączne pole tego, co pozostało po kroku \\(k\\), to \\((3/4)^k \\cdot \\sqrt{3}/2\\). W granicy mamy: \\[ \\lim_{k \\rightarrow \\infty} (3/4)^k \\cdot \\sqrt{3}/2 = 0. \\] Trójkąt Sierpińskiego jest zatem tak dziurawy, że ma pole równe 0. A jak długi jest jego brzeg? W kroku \\(k\\) brzeg zwiększa się o \\(3^{k-1}\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli obwodzie \\(3 \\cdot (1/2)^k\\). Łączny brzeg w kroku \\(k\\) to: \\[ \\sum_{i=1}^k 3^{k-1} \\cdot 3 \\cdot (1/2)^k = \\sum_{i=1}^k (3/2)^k. \\] Elementy tej sumy rosną do nieskończoności, więc tym bardziej cały brzeg trójkąta eksploduje do nieskończoności: \\[ \\lim_{k \\rightarrow \\infty}\\sum_{i=1}^k (3/2)^k = \\infty. \\] Co to za figura? Jest ograniczona, bo mieści się w trójkącie o boku 1, ale ma nieskończony obwód przy zerowym polu. Z jakiego to jest wymiaru? Prawdopodobnie do tego miejsca część czytelników zadaje sobie pytanie, czym są fraktale. Czy są to takie dziwne obrazki? A jeżeli tak, to jak je scharakteryzować? Jedną z częściej powtarzanych definicji fraktali jest definicja podana przez Mandelbrota, którą sparafrazuję do: Definicja (fraktal). Fraktalem nazywamy taki zbiór, którego wymiar fraktalny jest wyższy niż wymiar topologiczny. Jak się zaraz okaże, często wymiar fraktalny nie musi być liczbą całkowitą, stąd też nazwa fraktal, od francuskiego fractus oraz łacińskiego frangěre – złamać, postrzępić, cząstkowy. Ale czym jest ten wymiar topologiczny i fraktalny? 1.3.1 Wymiar topologiczny Gdy myślimy o przestrzeniach euklidesowych, wymiarem określa się liczbę prostopadłych kierunków rozpinających daną przestrzeń. Punkt w związku z tym ma wymiar 0, prosta ma wymiar 1, płaszczyzna ma wymiar 2, a wszyscy doświadczamy trójwymiarowej przestrzeni. Pewne obiekty możemy opisywać w przestrzeniach o wyższych wymiarach i nie ma tu żadnych ograniczeń. Matematyk z podekscytowaniem w głosie może opowiadać o przestrzeni funkcji, która jest nieskończenie wymiarowa. Podobnie możemy myśleć o wymiarach zbiorów. Intuicyjnie wymiarem zbioru będzie liczba prostopadłych odcinków, które można w tym zbiorze zmieścić. Należy jednak być ostrożnym. Niby wszystko się zgadza, punkt ma wymiar 0, odcinek ma wymiar 1, kwadrat ma wymiar 2, sześcian ma wymiar 3 i tak dalej. Jednak co zrobić z okręgiem? Nie mieści się w nim żaden odcinek. Ale przecież powinien mieć wymiar większy niż 0, bo to taki sklejony odcinek. Więc najlepiej, aby też miał wymiar 1. Sprawa jest więc trudniejsza. Matematycy głowili się nad nią długo, a formalna definicja wymiaru dla zbiorów jest dosyć młoda. Pierwsza indukcyjna definicja została zaproponowana niecałe 100 lat temu niezależnie przez Pawła Urysona i Karla Mengera (lata 1922–1923). Dzisiaj mamy różnych definicji wymiaru przynajmniej kilka. Zainteresowani znajdą je wraz z wieloma ciekawostkami w artykule Kilka słów o wymiarze [Nowa11]. Na potrzeby dalszego wywodu pozostaniemy przy intuicyjnej definicji – z liczbą prostopadłych odcinków, które można zanurzyć w analizowany zbiór. 1.3.2 Wymiar Minkowskiego, czyli fraktalny wymiar pudełkowy Definicji wymiaru fraktalnego jest też kilka, ale prawdopodobnie najpopularniejsza jest definicja Minkowskiego, nazywana często wymiarem pudełkowym. Określa się go dla obiektów geometrycznych zanurzonych w zwykłych \\(p\\)-wymiarowych przestrzeniach (my ograniczymy się praktycznie wyłącznie do \\(p=2\\)). Aby go wyznaczyć, musimy policzyć iloma \\(p\\)-wymiarowymi pudełkami o boku \\(\\varepsilon\\) można przykryć interesujący nas obiekt. Mandelbrot, pisząc o wymiarze fraktalnym, odnosił się do definicji wymiaru Hausdorffa, który jest uogólnieniem wymiaru Minkowskiego. W definicji Hausdorffa zamiast równymi pudełkami możemy analizowany obiekt przykrywać dowolną rodziną zbiorów o średnicach zbiegających do 0. Jeżeli przez \\(N(\\varepsilon)\\) określimy minimalną liczbę pudełek o boku \\(\\varepsilon\\) pokrywających obiekt \\(F\\), to wymiarem pudełkowym \\(d_F\\) tego obiektu jest: \\[ d_F = \\lim_{\\varepsilon \\rightarrow 0} \\frac{\\log N(\\varepsilon)}{\\log 1/\\varepsilon}. \\] W ogólności ta granica może nie istnieć. W takich sytuacjach osobno można rozważać kres górny i dolny tego ciągu. Ale dla obiektów przedstawionych w tej książce tak zdefiniowana granica zawsze do czegoś zbiega. Co więcej, nie ma znaczenia, jakiej wielkości pudełka wybieramy. Przykłady pokazuję dla pudełek, które ,,szczelnie’’ zakrywają fragmenty badanej figury, tak by ułatwić sobie obliczenia. Przyjmijmy na razie, że interesują nas pudełka o boku \\(\\varepsilon = 2^{-k}\\). Jeżeli chcemy przykryć nimi kwadrat o boku \\(1\\), to potrzebujemy ich przynajmniej \\(N(\\varepsilon) = 2^k * 2^k = 2^{2k}\\). Wymiar pudełkowy kwadratu to zatem: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{2k}}{\\log 1/2^{-k}} = 2. \\] A co z trójkątem Sierpińskiego? Tutaj wystarczy nam \\(N(\\varepsilon) = 3^k\\) kostek o boku \\(2^{-k}\\), a więc wymiar pudełkowy dla tego trójkąta to: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 3^{k}}{\\log 1/2^{-k}} = \\frac{\\log 3}{\\log 2} = 1,5849\\ldots \\] Rysunek 3 ilustruje, jak wygląda przykładowe pokrycie trójkąta Sierpińskiego kostkami o boku 1/4 i 1/8. Rysunek 3: Pokrycie trójkąta Sierpińskiego kostkami o boku 1/4 (lewy panel) i 1/8 (prawy panel) Jaki jest wymiar kurzu Cantora? Tym razem mamy obiekt zanurzony w przestrzeni jednowymiarowej, więc będziemy go przykrywać odcinkami. Przyjmijmy, że mamy odcinki o długości \\(\\varepsilon = 3^{-k}\\). Aby pokryć cały kurz Cantora wystarczy nam takich odcinków \\(N(\\varepsilon) = 2^k\\), czyli wymiar pudełkowy dla kurzu Cantora: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{k}}{\\log 1/3^{-k}} = \\frac{\\log 2}{\\log 3} = 0,6309\\ldots \\] BK: Niezwykłe jest to, że wymiar zbioru Cantora, którego wszystkie składowe są jednopunktowe (więc ma topologiczny wymiar 0), ma wymiar pudełkowy ostro większy od 0, i w dodatku ułamkowy. 1.3.3 Dywan Sierpińskiego Wiemy już, czym charakteryzują się fraktale, czas poznać kolejnych przedstawicieli tej niesamowitej rodziny. Bardzo znanym jej reprezentantem jest dywan Sierpińskiego. Receptura na konstrukcję dywanu Sierpińskiego. Weź kwadrat o dowolnej wielkości. Podziel ten kwadrat na dziewięć kwadratów. Usuń wnętrze środkowego kwadratu, otrzymasz osiem kwadratów o boku 1/3 wyjściowego kwadratu. Dla każdego z otrzymanych ośmiu kwadratów kontynuuj dzielenie, idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 4. Rysunek 4: Pierwsze cztery iteracje w konstrukcji dywanu Sierpińskiego Jaki jest wymiar pudełkowy tego tworu? Weźmy kostki o wielkości \\(\\varepsilon = 3^{-k}\\). Do zakrycia dywanu wystarczy nam \\(N(\\varepsilon) = 8^k\\) pudełek o boku \\(3^{-k}\\). Tak więc wymiar pudełkowy tego dywanu to: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 8^{k}}{\\log 1/3^{-k}} = \\frac{\\log 8}{\\log 3} = 1,8927... \\] 1.4 Przykłady w języku Python W tym rozdziale przedstawiamy przykłady kodu w programie Python, które pozwalają na narysowanie kolejnych przybliżeń Kurzu Cantora, Trójkąta Sierpińskiego i Dywanu Sierpińskiego. Każdy może opisywane fraktale odtworzyć na własnym komputerze. W tym celu można zainstalować interpreter języka Python. Kody generujące fraktale są krótkie i ich zrozumienie jest możliwe bez wcześniejszej znajomości tego języka, choć oczywiście warto ten język poznać. Kilka informacji, które pomogą w zrozumieniu kodów: Poniższe przykłady korzystają z biblioteki matplotlib, w której znajdują się funkcje do rysowania, jak np. funkcja plot() do rysowania odcinka oraz fill() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. Funkcja figure() tworzy pusty wykres, a show() wyświetla go na ekranie. Bardziej złożone funkcje matematyczne znajdują się w bibliotece math. W tych przykładach wykorzystamy ją, aby użyć funkcji pierwiastka kwadratowego sqrt(). W bibliotece numpy znajdują się funkcje do operacji na wektorach i macierzach. Wykorzystamy ją, by uprościć zapis operacji na dwuelementowych wektorach – współrzędnych punktów. W wielu miejscach korzystamy z rekurencji, a więc sytuacji, gdy funkcja wywołuje samą siebie. Nowe funkcje definiuje się z użyciem słowa kluczowego def. Jednym z argumentów przedstawionych funkcji rekurencyjnych jest depth – określa, ile razy funkcja ma się rekurencyjnie wywołać. 1.4.1 Kurz Cantora Rysowanie kurzu Cantora oprzemy na rekurencyjnej funkcji dust, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – wielkość fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Niezbędne biblioteki. import matplotlib.pyplot as plt import numpy as np # Jeżeli depth=1 to rysujemy odcinek, jeżeli depth&gt;1, # to rysujemy dwa małe kurze Cantora obok siebie. def dust(x, scale, depth): if depth &gt; 1: dust(x, scale / 3, depth - 1) dust(x + scale*2/3, scale / 3, depth - 1) else: plt.plot([x, x+scale], [0,0], color = &quot;black&quot;) # Inicjacja rysunku i narysowanie kurzu o głębokości 5. plt.figure() dust(0, scale = 1, depth = 5) plt.show() Wynik wykonania powyższych instrukcji 1.4.2 Trójkąt Sierpińskiego Czas na kultowy trójkąt. Aby go narysować, wykorzystamy rekurencyjną funkcję sierpinski, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informacje o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Wczytujemy niezbędne biblioteki. import matplotlib.pyplot as plt import numpy as np import math # Definiujemy funkcję rysującą trójkąt zaczepiony # w punkcie x o boku scale. def triangle(x, scale): plt.fill([x[0], x[0]+scale, x[0]+scale/2], [x[1], x[1], x[1]+scale*np.sqrt(3)/2], color = &quot;black&quot;) # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy zwykły trójkąt, jeżeli depth&gt;1, # to rysujemy trzy trójkąty obok siebie. def sierpinski(x, scale, depth): if depth &gt; 1: sierpinski(x, scale/2, depth-1) sierpinski(np.add(x, [scale/2, 0]), scale/2, depth-1) sierpinski(np.add(x,[scale/4,scale*np.sqrt(3)/4]), scale/2, depth-1) else: triangle(x, scale) # Inicjacja rysunku i narysowanie trójkąta o głębokości 4. plt.figure() sierpinski([0,0], scale = 1, depth = 4) plt.show() Wynik wykonania powyższych instrukcji 1.4.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów, np. dla kwadratu lub pięciokąta. Poniżej przykład dla kwadratu z dziurką, czyli dywanu Sierpińskiego. import matplotlib.pyplot as plt import numpy as np # Rekurencyjna funkcja do rysowania dywanu Sierpińskiego. # Jeżeli depth=1, to rysujemy kwadrat, używając funkcji square(), # jeżeli depth&gt;1, to rysujemy osiem fraktali obok siebie. def square(x, scale): plt.fill(np.add(x[0], [0, scale, scale, 0]), np.add(x[1], [0 0, scale,scale]), color=&quot;black&quot;) def carpet(x, scale, depth): if depth &gt; 1: carpet(x, scale/3, depth-1) carpet(np.add(x, [scale/3,0]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,0]), scale/3,depth-1) carpet(np.add(x, [0,scale/3]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,scale/3]), scale/3,depth-1) carpet(np.add(x, [0,2*scale/3]), scale/3,depth-1) carpet(np.add(x, [scale/3,2*scale/3]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,2*scale/3]), scale/3,depth-1) else: square(x, scale) plt.figure() carpet([0,0], scale = 1, depth = 4) plt.show() Wynik wykonania powyższych instrukcji 1.5 Przykłady w języku R Drogi Czytelniku, możesz opisywane fraktale odtworzyć na swoim komputerze, wystarczy tylko zainstalowany interpreter języka R, który można bezpłatnie pobrać i zainstalować ze strony [https://cran.r-project.org/]. Nie jest niezbędna wcześniejsza znajomość tego języka, choć oczywiście byłaby przydatna. Poniżej kilka informacji, które pomogą w zrozumieniu tego kodu. Poniższe przykłady korzystają z podstawowej biblioteki graficznej dla R, czyli graphics. Nie trzeba jej wczytywać, ponieważ jest dostępna od razu po uruchomieniu R. Funkcja plot.new() tworzy pusty wykres. Jest on wypełniany przez użycie funkcji polygon() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. R to język dla matematyków i statystyków, więc większość operacji matematycznych jest dostępna od razu po uruchomieniu konsoli, tak jak funkcja sqrt() potrzebna do wyliczenia wysokości trójkąta równobocznego. Program R działa natywnie na wektorach, co znaczy, że możemy używać arytmetycznych operatorów takich jak + czy / zarówno do liczb, jak i do wektorów. Aby kod był bardziej czytelny, korzystamy z rekurencji, a więc konstrukcji, w której funkcja sama się wywołuje. Nowe funkcje definiuje się z użyciem słowa kluczowego function. Przedstawione funkcje mają argument depth, określający, ile jeszcze razy funkcja ma wywołać samą siebie. 1.5.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informację o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Rekurencyjna funkcja do rysowania kurzu. Jeżeli depth=1 # to rysuje odcinek, jeżeli depth&gt;1 to rysujemy dwa # kurze Cantora obok siebie. dust = function(x, y, scale, depth = 1) { if (depth == 0) { lines(c(x, x + scale), c(y, y)) } else { dust(x, y, scale/3, depth - 1) dust(x + scale*2/3, y, scale/3, depth - 1) } } # Czyścimy ekran i zaczynamy rysowanie kurzu. plot.new() dust(0, 0, scale = 1, depth = 4) Wynik wykonania powyższych instrukcji 1.5.2 Trójkąt Sierpińskiego Czas na kultowy trójkąt Sierpińskiego. Aby go narysować, wykorzystamy rekurencyjną funkcję sierpinski(), która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informację o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. triangle &lt;- function(x, y, scale) { polygon(x + scale*c(0, 1, 1/2), y + scale*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy trójkąt, używając funkcji triangle(), # jeżeli depth&gt;1, to rysujemy trzy trójkąty obok siebie. sierpinski &lt;- function(x, y, scale, depth = 1) { if (depth == 0) { triangle(x, y, scale) } else { sierpinski(x, y, scale/2, depth-1) sierpinski(x+scale/2, y, scale/2, depth-1) sierpinski(x+scale/4, y+sqrt(3)*scale/4,scale/2,depth-1) } } plot.new() sierpinski(0, 0, scale = 1, depth = 6) Wynik wykonania powyższych instrukcji 1.5.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów. # Rekurencyjna funkcja do rysowania dywanu. # W zależności od aktualnej głębokości albo rysuje kwadrat # albo, rekurencyjnie ośmiokrotnie wywołuje samą siebie carpet = function(x, y, scale, depth = 1) { if (depth == 1) { rect(x, y, x + scale, y + scale, col = &quot;black&quot;) } else { carpet(x, y, scale/3, depth - 1) carpet(x+scale*1/3, y, scale/3, depth - 1) carpet(x+scale*2/3, y, scale/3, depth - 1) carpet(x, y+scale*1/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*1/3, scale/3, depth - 1) carpet(x, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*1/3, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*2/3, scale/3, depth - 1) } } plot.new() carpet(0, 0, scale = 1, depth = 4) Wynik wykonania powyższych instrukcji 1.6 Przykłady w języku Julia Tworząc fraktale pewne operacje musimy powtarzać w nieskończoność, lub przynajmniej bardzo długo. Świetnie się do tego nadają wydajne, elastyczne i bardzo bardzo szybkie języki programowania. Takim właśnie językiem jest Julia. Interpreter tego języka i dokumentację można pobrać ze strony [https://julialang.org/]. Poniżej prezentujemy kilka informacji, które pomogą w zrozumieniu kolejnych przykładów. Poniższe przykłady korzystają z biblioteki Plots, podstawowej biblioteki dla języka Julia. Funkcja plot() z tej biblioteki tworzy pusty wykres. Można do niego dorysować kolejne figury funkcją plot!(). W poniższych przykładach tak będziemy tworzyć dodatkowe wypełnione wielokąty, trójkąty i kwadraty. Julia to język bardzo przyjazny operacjom matematycznym, można bez dodatkowych modułów korzystać z funkcji matematycznych, takich jak sqrt(). Operatory arytmetyczne takie jak + czy / działają zarówno dla liczb jak i dla wektorów. Aby kod był bardziej czytelny korzystamy z rekurencji, a więc konstrukcji, w której funkcja, sama się wywołuje. Nowe funkcje definiuje się z użyciem słowa function. W przypadku krótszych funkcji można stosować uproszczoną definicje z operatorem =. Z krótszego sposobu skorzystamy definiując funkcje line, triangle, square. 1.6.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od Kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x – początek fraktala, scale – wielkość fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Pakiet z funkcjami graficznymi. using Plots # Funkcja definiująca odcinek. line(x, scale) = Shape([x, x+scale], [0, 0]) # Rekurencyjna funkcja do rysowania kurzu. # Jeżeli depth=1, to rysujemy odcinek, jeżeli depth&gt;1, # to rysujemy dwa kurze Cantora obok siebie. function dust(x, scale, depth=1) if depth == 0 plot!(line(x, scale), color=:black, legend=:false) else dust(x, scale/3, depth - 1) dust(x + scale*2/3, scale/3, depth-1) end end # Czyścimy ekran i zaczynamy rysowanie kurzu. plot(0, xlim=(-0.1,1.1), ylim=(-0.1,0.1), axis=nothing) dust(0.0, 1.0, 4) Wynik wykonania powyższych instrukcji 1.6.2 Trójkąt Sierpińskiego Czas na kultowy trójkąt Sierpińskiego. Aby go narysować wykorzystamy rekurencyjną funkcję sierpinski(), która przyjmuje trzy argumenty: x, y – miejsce od którego należy rysować fraktal, scale – wielkość fraktalu oraz depth aktualny poziom zagnieżdżenia fraktala. triangle(x, y, scale) = Shape([x, x+scale, x+scale/2, x], [y, y, y+scale*sqrt(3)/2, y]) # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy trójkąt używając funkcji triangle(), # jeżeli depth&gt;1. to rysujemy trzy trójkąty Sierpińskiego. function sierpinski(x, y, scale, depth=1) if depth==0 plot!(triangle(x,y,scale),color=:black,legend=:false) else sierpinski(x, y, scale/2, depth-1) sierpinski(x+scale/2, y, scale/2, depth-1) sierpinski(x+scale/4,y+sqrt(3)*scale/4,scale/2,depth-1) end end plot(0, xlim=(0,1), ylim=(0,1), axis=nothing) sierpinski(0, 0, 1, 6) Wynik wykonania powyższych instrukcji 1.6.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów. square(x, y, w) = Shape([x, x+w, x+w, x], [y, y, y+w, y+w]) # Wykorzystujemy funkcje square zdefiniowaną powyżej aby narysować kwadrat. function carpet(x, y, scale, depth=1) if depth==0 plot!(square(x,y,scale), color=:black, legend=:false) else carpet(x, y, scale/3, depth-1) carpet(x, y+scale, scale/3, depth-1) carpet(x, y+2scale, scale/3, depth-1) carpet(x+scale, y, scale/3, depth-1) carpet(x+scale, y+2scale, scale/3, depth-1) carpet(x+2scale, y, scale/3, depth-1) carpet(x+2scale, y+scale, scale/3, depth-1) carpet(x+2scale, y+2scale, scale/3, depth-1) end end plot(0, xlim=(0,3), ylim=(0,3), axis=nothing) carpet(0.0, 0.0, 1.0, 5) Wynik wykonania powyższych instrukcji Bibliografia "],["fraktal-czyli-punkt-stały.html", "Rozdział 2 Fraktal, czyli punkt stały 2.1 Stefan Banach 2.2 Fraktal, czyli punkt stały 2.3 Ale dlaczego to działa? 2.4 Przykłady w języku Python 2.5 Przykłady w języku R 2.6 Przykłady w języku Julia", " Rozdział 2 Fraktal, czyli punkt stały Rozdział, w którym dowiadujemy się, czym jest kontrakcja, a także poznajemy wiele matematycznych obiektów. Beta i Bit spotykają Stefana Banacha w Kawiarni Szkockiej we Lwowie Stefan Banach w marudzeniu znudzonego Bita odnajduje ciekawe twierdzenie 2.1 Stefan Banach W 1892 roku w Krakowie urodził się jeden z najwybitniejszych matematyków XX wieku, genialny samouk, człowiek legenda – Stefan Banach. Matematyką interesował się już w gimnazjum, ale traktował ją raczej jako hobby. Seria przypadków zdecydowała o tym, że stał się czołowym reprezentantem lwowskiej szkoły matematycznej. W szkole średniej Banach zaprzyjaźnił się z kolegą ze szkolnej ławy Witoldem Wilkoszem, późniejszym profesorem matematyki na Uniwersytecie Jagiellońskim, z którym rozmawiał o rozmaitych matematycznych zagadkach. Później do tego grona matematycznych zapaleńców dołączył Otto Nikodym i to właśnie jedna z rozmów o matematyce pomiędzy Banachem a Nikodymem doprowadziła do spotkania z Hugonem Steinhausem. Steinhaus dostrzegł olbrzymi talent matematyczny młodego Banacha, stworzył mu warunki, które szybko doprowadziły do rozwoju jednego z najbardziej twórczych, oryginalnych umysłów matematycznych. W 1920 roku, dzięki staraniom Hugona Steinhausa, Banach otrzymał posadę asystenta na Politechnice Lwowskiej u Antoniego Łomnickiego. Talent matematyczny i ciężka praca szybko przyniosły owoce. W pracy doktorskiej Banach zawarł nowe, dziś podstawowe twierdzenia rodzącej się dyscypliny matematyki – analizy funkcjonalnej. Jednym z wyników było zdefiniowanie ,,przestrzeni B’’, która dzisiaj jest nazywana przestrzenią Banacha. Przestrzeń Banacha to przestrzeń liniowa, unormowana, w której metryka wyznaczona przez normę jest zupełna. Definicja tych właściwości wykracza poza zakres tej książeczki, ale o liniowości i zupełności coś w tym rozdziale jeszcze napiszemy. O życiu Banacha krąży wiele anegdot. Jedna z nich dotyczy uzyskania stopnia doktora. Zgodnie z anegdotą Banach na tyle nie dbał o formalne tytuły, że nie zamierzał starać się o doktorat. Jego przełożeni, widząc talent matematyka i uważając, że stopień doktora jest potrzebny, uknuli intrygę. Rozprawę doktorską złożyli z luźnych notatek z twierdzeniami, a na egzamin doktorski ściągnęli go podstępem, mówiąc, że z Warszawy przyjechała delegacja, która ma kilka ciekawych problemów matematycznych i trzeba im wytłumaczyć rozwiązania. W rzeczywistości Banach skończył normalne studia doktorskie, ale jego lekceważący stosunek do tytułów był pożywką dla anegdot. Tak błyskotliwy umysł przyciągał inne błyskotliwe umysły. Jeszcze w 1919 roku Banach współtworzył Towarzystwo Matematyczne w Krakowie, które później przekształciło się w Polskie Towarzystwo Matematyczne. Już we Lwowie razem ze Steinhausem założyli lwowską szkołę matematyczną, która specjalizowała się w analizie funkcjonalnej. Była to kuźnia niesamowitych talentów, dość wymienić kilku jej przedstawicieli: Stanisław Ulam, Władysław Orlicz, Mark Kac czy Stanisław Mazur. Ulubionym miejscem pracy Stefana Banacha była Kawiarnia Szkocka, gdzie przy kawie, koniaku czy muzyce spotykał się z innymi matematykami, by pracować nad fascynującymi ich problemami. Problemy te były początkowo spisywane na serwetkach lub stole, do czasu, gdy Łucja, żona Banacha, wyposażyła grupę w gruby zeszyt. Ten zeszyt to legendarna Księga szkocka, w której matematycy lwowscy zapisywali problemy matematyczne do rozwiązania. Co trudniejsze problemy miały zapisy o nagrodzie za ich rozwiązanie. Nagrody były równie oryginalne, jak i cała szkoła lwowska. Dość powiedzieć, że jedną z nich była żywa gęś. Do dziś nie wszystkie problemy znalazły rozwiązanie. Nazwisko Banacha znajduje się w wielu matematycznych twierdzeniach czy innych niesamowitych wynikach. Jednym z nich jest paradoks Banacha–Tarskiego, twierdzenie mówiące, że można trójwymiarową kulę rozciąć na skończoną liczbę części, z których po odpowiednim obrocie i przesunięciu można złożyć dwie kule o takim samym rozmiarze. Niesamowicie pomysłowa konstrukcja, pozornie niemożliwa. Jak z obrotami dwukrotnie powiększyć objętość kuli? Okazuje się, że wystarczy, by podzbiory były niemierzalne i już można robić z nimi matematyczne cuda. Życie Banacha pełne jest niesamowitych zwrotów akcji. Przed drugą wojną światową był uznanym profesorem matematyki. Pewnego dnia przyjechał do Lwowa John von Neumann, by sprowadzić Banacha do Stanów Zjednoczonych. Miał wręczyć Banachowi czek z wpisaną cyfrą 1 oraz oświadczyć, że ten może dopisać tyle zer, ile uzna za stosowne. Na to Banach miał odpowiedzieć, że ,,to za mało by wyjechać z Polski’’. Ale wojna pozbawiła go i wielu innych badaczy możliwości pracy zarobkowej. Część wojny spędził jako karmiciel wszy w Instytucie Badań nad Tyfusem u profesora Rudolfa Weigla. Nie jest to praca marzeń, choć była bardzo cenna, bo pozwalała na uniknięcie części represji stosowanych przez okupantów. Steinhaus powiedział kiedyś o Banachu, że ,,łączył w sobie iskrę geniuszu z jakimś zadziwiającym imperatywem wewnętrznym, który mu mówił bezustannie słowami poety &lt;&gt; – a matematycy wiedzą dobrze, że ich rzemiosło polega na tej samej tajemnicy, co rzemiosło poetów…’’. 2.2 Fraktal, czyli punkt stały Gwoździem programu będzie w tym rozdziale twierdzenie Banacha o punkcie stałym i związek tego twierdzenia z fraktalami. Zaczniemy od pokazania konstrukcji kilku nowych ciekawych figur, takich jak smok Heighwaya czy paproć Barnsleya. Zaspokoiwszy pierwszą ciekawość, zagłębimy się w podstawy matematyczne tych figur. Dla osób, które studiowały matematykę, może to być przypomnienie pewnych pojęć z analizy matematycznej czy topologii. Dla osób, które matematyki nie studiowały, może to być interesujące spojrzenie na to, jak matematycy formułują tezy. 2.2.1 Smoki i paprocie Pierwszy rozdział zostawił nas z metodą konstrukcji trzech fraktali. Każdy z nich można było wykonać przez powtarzanie w kółko następujących kroków. Algorytm konstrukcji prostych fraktali. Weź jakąś figurę. Skopiuj ją \\(x\\) razy. Pomniejsz ją \\(y\\)-krotnie. Pomniejszone kopie poprzesuwaj. Wróć do kroku 2. W przypadku kurzu Kantora kopiowaliśmy \\(x=2\\) razy, a pomniejszaliśmy \\(y=3\\) razy. Dla trójkąta Sierpińskiego kopiowaliśmy \\(x=3\\) razy, a pomniejszaliśmy \\(y=2\\) razy. Dla dywanu Sierpińskiego kopiowaliśmy \\(x=8\\) razy, a pomniejszaliśmy \\(y=3\\) razy. Okazuje się, że w bardzo podobny sposób można stworzyć więcej różnych fraktali. A jeżeli obok skalowania i przesuwania pozwolimy jeszcze na obroty, to otrzymamy bardzo bogatą klasę różnorodnych ciekawych figur. Złożenie skalowania, przesuwania i obrotu jest na tyle ważną operacją, że doczekało się własnej nazwy: przekształcenie afiniczne. W kroku 1 powyższego algorytmu wybieramy dowolną figurę. Ale im więcej razy powtarzamy krok 3 tego algorytmu, tym mniejsze są wybrane figury. W rzeczywistości wybór tej figury nie ma znaczenia, równie dobrze możemy na początku wykorzystać rysunek trójkąta czy słonia, czy małej kropki. Jak to możliwe? To będzie główny wniosek z twierdzenia Banacha o punkcie stałym. Weźmy słonia i zróbmy z niego uszczelkę. Po sześciu iteracjach słoń i tak robi się wielkości ziarenka piasku Ale najpierw poznajmy trzy nowe fraktale. 2.2.2 Pięciokąt Sierpińskiego (ang. Sierpiński pentagon) Sztuczkę z trójkątem czy kwadratem możemy powtórzyć z każdym wielokątem foremnym, np. pięciokątem. Jeżeli będziemy wyjściową figurę kopiować pięciokrotnie, następnie zmniejszać ją o \\(\\frac{3-\\sqrt 5}2 \\approx 0,382\\), a następnie przesuwać w rogi pięciokąta, tak by zmniejszone figury stykały się wierzchołkami, to powtarzając tę procedurę wielokrotnie, uzyskamy figurę nazywaną pięciokątem Sierpińskiego. Pięciokąt Sierpińskiego. Wynik pięciokrotnego kopiowania wejściowej figury, pomniejszania i przesuwania tych kopii. Każdą z pięciu kopii oznaczono innym kolorem Ale prawdziwa magia zaczyna się, gdy w tych transformacjach pozwolimy na obroty. Rozważmy poniższy algorytm. Algorytm konstrukcji złożonych fraktali. Weź jakąś figurę. Skopiuj ją \\(x\\) razy. Pomniejsz ją \\(y\\)-krotnie. Pomniejszone kopie obróć i/lub przesuń. Idź do kroku 2. Zobaczmy, jak ten algorytm działa na przykładzie kilku ciekawych zestawów transformacji. 2.2.3 Drzewo Pitagorasa Konstrukcja tego fraktala została opisana w 1942 roku przez Alberta Bosmana. Jest kilka różnych wariantów budowy tej figury, poniżej przedstawiamy konstrukcję opartą na dwóch transformacjach. Transformacja 1: obróć figurę o \\(45^{\\circ}\\) w lewo, a następnie przeskaluj ją współczynnikiem \\(1/\\sqrt{2}\\). Transformacja 2: obróć figurę o \\(45^{\\circ}\\) w prawo, a następnie przeskaluj ją współczynnikiem \\(1/\\sqrt{2}\\). Poniższy obrazek ilustruje fraktal oraz przedstawia samopodobieństwo wynikające ze składanych transformacji. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Panel A przedstawia drzewo Pitagorasa, panel B ilustruje dwie transformacje składające się na fraktal. Obraz jest zmniejszany sqrt(2) razy i obracany o 45 stopni, każdą z dwóch replikacji oznaczono innym kolorem 2.2.4 Smok Heighwaya Okazuje się, że bardzo wiele ciekawych figur można uzyskać dwiema transformacjami. Jedną z nich jest smok Heighwaya, którego konstrukcję pokazali po raz pierwszy John Heighway, Bruce Banks i William Harter z NASA. Smok jest oparty na takich dwóch transformacjach: Transformacja 1: obróć figurę o \\(45^{\\circ}\\) w lewo, a następnie przeskaluj ją współczynnikiem \\(1/\\sqrt 2\\). Transformacja 2: obróć figurę o \\(45^{\\circ}\\) w lewo, a następnie przeskaluj ją współczynnikiem \\(1/\\sqrt 2\\) i przesuń o 1 wzdłuż osi poziomej. Poniższy obrazek ilustruje smoka i obie transformacje. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Panel A przedstawia smoka Heighwaya, panel B ilustruje dwie transformacje składające się na fraktal. Każdą z dwóch replikacji oznaczono innym kolorem 2.2.5 Paproć Bernseya Dwiema transformacjami można uzyskać bardzo wiele, a co się stanie, gdy dodamy kolejne? Zobaczmy na przykładzie jednego z najpopularniejszych fraktali – paproci Barnsleya. Została ona po raz pierwszy opisana w 1993 roku przez brytyjskiego matematyka Michaela Barnsleya, który badał fraktale ze względu na ich potencjał we fraktalnej kompresji. Do paproci będziemy potrzebowali potrzebowali czterech transformacji: Transformacja 1 (lewy liść): obróć figurę o \\(10^{\\circ}\\) w lewo, a następnie przeskaluj ją współczynnikiem \\((0,5; 0,3)\\). Transformacja 2 (prawy liść): obróć figurę o \\(15^{\\circ}\\) w prawo, a następnie przeskaluj ją współczynnikiem \\((0,45; 0,25)\\). Transformacja 3 (góra): obróć figurę o \\(1^{\\circ}\\) w prawo, a następnie przeskaluj ją współczynnikiem \\(0,9\\) i przesuń o \\(0,01\\) wzdłuż osi X. Transformacja 4 (łodyga): przeskaluj figurę współczynnikiem \\((0,25; 0)\\). Poniższy obrazek ilustruje paproć i wszystkie cztery transformacje. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Panel A przedstawia paproć Barnsleya, panel B ilustruje cztery transformacje składające się na fraktal. Każdą z czterech replikacji oznaczono innym kolorem 2.3 Ale dlaczego to działa? Pokazane figury mają bardzo ciekawy opis matematyczny. Przedstawiamy go poniżej na poziomie szczegółowości pierwszych lat studiów matematycznych. Najpierw zdefiniujemy kilka niezbędnych pojęć, w oparciu o które będziemy mogli przedstawić twierdzenie o punkcie stałym. Zazwyczaj, myśląc o figurach i odległościach, skupiamy się na bardzo klasycznej płaszczyźnie z dwiema osiami i zwykłą euklidesową odległością. Ale na potrzeby zbliżającego się twierdzenia musimy spojrzeć na pewne rzeczy nieco bardziej abstrakcyjnie. 2.3.1 Przestrzeń metryczna W naszej historii bardzo ważną rolę będą odgrywały odległości pomiędzy punktami. Dlatego w dalszej części tego rozdziału często będziemy pisać o przestrzeni metrycznej. Co to takiego? Definicja (przestrzeń metryczna). Przestrzeń metryczna to zbiór \\(X\\) z określoną metryką (odległością) \\(d\\) pomiędzy punktami tego zbioru. Inaczej mówiąc, jeżeli pracujemy z przestrzenią metryczną, to dla każdej pary punktów \\(a\\) i \\(b\\) potrafimy wyznaczyć ich odległość \\(d(a,b)\\). Definicja (odległość). Odległość to funkcja \\(d(a,b)\\) określona dla każdych dwóch punktów \\(a, b \\in X\\) spełniająca jednocześnie trzy warunki: \\(d(a,b) = 0 \\Leftrightarrow a = b\\), odległość wynosi zero wtedy i tylko wtedy, gdy punkty są sobie równe, \\(d(a,b) = d(b,a)\\), odległość jest symetryczna, \\(d(a,b) \\leq d(a,c) + d(c,b)\\), warunek trójkąta, czyli odległość pomiędzy dowolnymi dwoma punktami jest zawsze mniejsza lub równa niż suma odległości tych punktów od dowolnego innego punktu \\(c\\). Większość z nas w codziennym życiu operuje w przestrzeni euklidesowej, ze zwykłą ,,linijkową’’ odległością. Ale aby pracować z fraktalami, potrzebujemy bardziej wyrafinowanych linijek. 2.3.2 Odległość Hausdorffa W świecie fraktali odległość pomiędzy punktami mierzy się bardzo przewrotnie – stosując odległość Hausdorffa. Ta odległość określa, jak daleko od siebie są dwie figury (w sensie: zbiory punktów). Mamy dwa zbiory punktów A i B w przestrzeni metrycznej z metryką \\(d\\) i chcemy określić, jak daleko od siebie są te zbiory. Intuicja stojąca za tą metryką jest następująca: zbiory są blisko siebie, jeżeli dla każdego punktu z jednego zbioru można znaleźć jakiś punkt z drugiego zbioru, który jest do niego bliski. Jeżeli każdy punkt ze zbioru \\(A\\) ma takiego ,,towarzysza’’ ze zbioru \\(B\\), to są one blisko. Spróbujmy to zapisać formalnie. Definicja (odległość Hausdorffa). Odległość Hausdorffa pomiędzy dwoma niepustymi zbiorami \\(A\\) i \\(B\\) określona jest jako \\[ d_H(A, B) = \\max \\left\\{ \\sup_{a\\in A} \\inf_{b\\in B} d(a, b); \\sup_{b \\in B} \\inf_{a \\in A} d(a, b) \\right\\}. \\] Technicznie rzecz biorąc, odległość Hausdorffa jest określona dla zwartych niepustych zbiorów. Można ją stosować też dla zbiorów domkniętych, ale wtedy może przyjmować wartości nieskończone. My będziemy pracować na zbiorach zwartych, ale można nie mówić tego na głos i pewnie wiele osób nawet nie zauważy różnicy. Ilustracja odległości Hausdorffa Zapis może przerazić, ale jeżeli rozłożyć go na części, to okaże się bardzo intuicyjny. Cześć \\(\\inf_{b\\in B} d(a, b)\\) oznacza najmniejszą odległość od punktu \\(a\\) do dowolnego punktu ze zbioru \\(B\\). W takim razie \\(\\sup_{a\\in A} \\inf_{b\\in B} d(a, b)\\) to odległość najbardziej odstającego punktu ze zbioru \\(A\\). Odległość musi być symetryczna, więc we wzorze \\(d_H(A, B)\\) mamy maksimum z odstawiania zbioru \\(A\\) od \\(B\\) i odwrotnie. 2.3.3 Ciąg Cauchy’ego Drogi Czytelniku, jak już pewnie zauważyłeś, konstruując fraktale, powtarzamy pewne czynności w kółko. Tu i tam pojawia się sugestia, że należy to robić w nieskończoność. Zabawa w nieskończoność jest jednak ryzykowna, szczególnie, jeżeli nie mamy gwarancji, że gdzieś zbiegniemy. Skąd wziąć te gwarancje? Definicja (ciąg Cauchy’ego). Ciąg Cauchy’ego to ciąg punktów \\(a_n\\), w którym dla dowolnej większej od zera liczby \\(\\varepsilon\\) można znaleźć taki element ciągu \\(N\\), że odległość pomiędzy wszystkimi dalszymi elementami jest mniejsza od \\(\\varepsilon\\). \\[ \\forall_{\\varepsilon &gt;0} \\exists_N \\forall_{m,n&gt;N} d(a_m,a_n) \\leq \\varepsilon. \\] 2.3.4 Przestrzeń zupełna Ciągi zbieżne spełniają warunek Cauchy’ego, ale są też takie przestrzenie, w których ciągi Cauchy’ego nie są zbieżne. To nie są porządne przestrzenie, więc dalej będziemy operować tylko na porządnych przestrzeniach, czyli przestrzeniach zupełnych. Definicja (przestrzeń zupełna). Przestrzeń metryczna \\((X,d)\\) jest zupełna, jeżeli każdy ciąg \\(a_n \\subset X\\) spełniający warunek Cauchy’ego jest zbieżny w \\(X\\). I to są właśnie gwarancje ,,porządności’’, których potrzebowaliśmy. 2.3.5 Kontrakcja Mamy porządną przestrzeń, teraz porozmawiajmy o transformacjach. Do konstrukcji fraktali możemy wykorzystywać specyficzne transformacje, które zbliżają punkty. Będziemy je nazywać przekształceniami zwężającymi lub w skrócie kontrakcjami. Definicja (kontrakcja). Przekształcenie \\(T\\) jest przekształceniem zwężającym (kontrakcją), jeżeli istnieje stała \\(\\lambda &lt; 1\\) taka, że \\[ \\forall_{x,y} d(T(x), T(y)) \\leq \\lambda d(x,y). \\] Czyli dla dowolnych dwóch punktów \\(x\\) i \\(y\\) po przekształceniu są one bliżej niż przed. W przykładach, o których rozmawialiśmy na początku rozdziału, każda pokazana transformacja była kontrakcją. Dlaczego? Transformacje składały się z obrotów, przesunięć i skalowania. Obrót i przesunięcie nie zmieniają odległości pomiędzy punktami, a wszystkie skalowania były wykonywane ze skalą mniejszą niż 1 dla każdej z osi. 2.3.6 Przekształcenie afiniczne Kontrakcje to bardzo szeroka klasa transformacji. My ograniczamy się do znacznie węższej klasy transformacji liniowych z przesunięciami, czyli tzw. przekształceń afinicznych. Przekształcenie afiniczne to złożenie skalowania, obrotu i przesunięcia. Jeżeli skalowanie zmniejsza figurę, to takie przekształcenie afiniczne jest kontrakcją, ponieważ obrót i przesunięcie nie zmienia odległości. Przekształcenia afiniczne można łatwo opisać w postaci algebraicznej jako mnożenie punktu przez macierz przekształcenia. Pozwoli nam to skrócić zapis kodu generującego fraktal: \\[ T_{rotate, \\alpha}(x) = \\begin{bmatrix} \\cos(\\alpha) &amp; -\\sin(\\alpha) \\\\ \\sin(\\alpha) &amp; \\cos(\\alpha) \\end{bmatrix} x, \\] \\[ T_{scale, a, b}(x) = \\begin{bmatrix} a &amp; 0 \\\\ 0 &amp; b \\end{bmatrix} x, \\] \\[ T_{shift, a, b}(x) = x + \\begin{bmatrix} a \\\\ b \\end{bmatrix}. \\] 2.3.7 Twierdzenie Hutchinsona W tym miejscu ktoś powie: ,,OK, każda z transformacji jest kontrakcją, ale czy ich złożenie też musi być kontrakcją?’’. Konstruując trójkąt Sierpińskiego, co prawda pomniejszaliśmy figurę, ale później kopiowaliśmy ją trzy razy. Okazuje się, że suma kontrakcji też jest kontrakcją – i dokładnie o tym mówi twierdzenie Hutchinsona. Twierdzenie Hutchinsona. Przekształcenie \\(T = T_1 \\cup T_2 \\cup ... \\cup T_k\\) jest zwężające, jeśli wszystkie przekształcenia \\(T_1, ..., T_k\\) użyte do zdefiniowania przekształcenia \\(T\\) są zwężające. Dowód tego twierdzenia nie jest długi, można go znaleźć np. w ,,Delcie’’ z lipca 2011 roku [Kici11]. 2.3.8 Twierdzenie Banacha o punkcie stałym Mamy już wszystko, czego potrzebowaliśmy do pokazania twierdzenia Banacha o punkcie stałym, czyli porządną przestrzeń z porządną odległością, w której używamy operatora \\(T\\), który jest kontrakcją. Precyzyjniej: Twierdzenie Banacha o punkcie stałym. Jeśli \\((X, d)\\) jest przestrzenią metryczną zupełną, a \\(T: X\\to X\\) jest kontrakcją, to \\(T\\) ma dokładnie jeden punkt stały \\(x\\in X\\). Puntem stałym przekształcenia \\(T\\) jest taki punkt \\(x\\), że \\(T(x) = x\\). Dowód tego twierdzenia Banach przedstawił w swojej pracy doktorskiej. Nie jest on zbyt skomplikowany, można go znaleźć np. w ,,Delcie’’ z lipca 2011 roku. Tutaj ograniczymy się jedynie do pokazania, jak szukać tego punktu stałego. Otóż okazuje się, że dla dowolnego punktu \\(x\\) przestrzeni \\(X\\) ciąg \\(T^n(x)\\) zbiega do punktu stałego, gdzie \\(T^n(x)\\) oznacza n-krotne złożenie przekształcenia \\(T\\), czyli \\(T(T(T(...T(x)...)))\\). Wystarczy zatem w nieskończoność składać kontrakcje, by znaleźć ich punkt stały. I takim punktem stałym są konstruowane przez nas fraktale. 2.4 Przykłady w języku Python Przykłady przedstawione w tym rozdziale powtarzają złożenie trzech atomowych transformacji – przesunięcia, przeskalowania i obrotu. Poniżej znajdują się definicje tych trzech przekształceń. W poniższych przykładach x jest dwuelementowym wektorem. import numpy as np import matplotlib.pyplot as plt # Przesunięcie punktu x o wektor delta. def shift(x, delta): return np.add(x, delta) # Przeskalowanie punktu x razy ratio. def scale(x, ratio): return np.multiply(x, ratio) # Obrót o kąt alpha (w stopniach). def rotate(x, alpha): adeg = math.pi * alpha / 180 rotation_matrix = [ [np.cos(adeg), -np.sin(adeg)], [np.sin(adeg), np.cos(adeg)]] return np.matmul(x, rotation_matrix) 2.4.1 Trójkąt Sierpińskiego Tak jak napisaliśmy na początku tego rozdziału, fraktale możemy budować ze zwykłych kropek, nie potrzebujemy bardziej wyrafinowanych poligonów. Przedstawmy to na bazie trójkąta Sierpińskiego. Trójkąt Sierpińskiego składa się z trzech transformacji. \\[ y_1 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] \\] \\[ y_2 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.5 \\\\ 0 \\end{smallmatrix}\\right] \\] \\[ y_3 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.25 \\\\ \\sqrt3/4 \\end{smallmatrix}\\right] \\] import matplotlib.pyplot as plt import numpy as np # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # Poniższy program powtarza złożenie tych funkcji depth razy. # W teorii robilibyśmy to w nieskończoność, ale do uzyskania # wyraźnego obrazka wystarczy kilka kroków. # Liczba punktów rośnie wykładniczo, więc po k krokach wynosi 3^k. def sierpinski(x, depth): if depth &gt; 1: x1 = scale(shift(x, [0, 0]), [0.5, 0.5]) sierpinski(x1, depth - 1) x2 = scale(shift(x, [0.5, 0]), [0.5, 0.5]) sierpinski(x2, depth - 1) x3 = scale(shift(x, [0.25, 0.5]), [0.5, 0.5]) sierpinski(x3, depth - 1) else: plt.plot(x[0], x[1], marker=&#39;o&#39;, color=&quot;black&quot;, markersize=3) # Inicjacja rysunku i narysowanie trójkąta Sierpińskiego. plt.figure() sierpinski([0,0], depth = 7) plt.show() Wynik wykonania powyższych instrukcji 2.4.2 Pięciokąt Sierpińskiego import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) def pentagon(x, depth, col=&quot;black&quot;): if depth &gt; 1: x1 = shift(scale(x, [0.382,0.382]), [0,0]) pentagon(x1, depth-1, col=&quot;red&quot;) x2 = shift(scale(x, [0.382,0.382]), [0.618,0]) pentagon(x2, depth-1, col=&quot;blue&quot;) x3 = shift(scale(x, [0.382,0.382]), [0.809,0.588]) pentagon(x3, depth-1, col=&quot;green&quot;) x4 = shift(scale(x, [0.382,0.382]), [0.309,0.951]) pentagon(x4, depth-1, col=&quot;orange&quot;) x5 = shift(scale(x, [0.382,0.382]), [-0.191,0.588]) pentagon(x5, depth-1, col=&quot;brown&quot;) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color=col, markersize=3) plt.figure() pentagon([0,0], depth=6, col) plt.show() Wynik wykonania powyższych instrukcji 2.4.3 Smok Heighwaya import math import numpy as np import matplotlib.pyplot as plt import numpy as np import matplotlib.pyplot as plt # Przesunięcie punktu x o wektor delta. def shift(x, delta): return np.add(x, delta) # Przeskalowanie punktu x razy ratio. def scale(x, ratio): return np.multiply(x, ratio) # Obrót o kąt alpha (w stopniach). def rotate(x, alpha): adeg = math.pi * alpha / 180 rotation_matrix = [ [np.cos(adeg), -np.sin(adeg)], [np.sin(adeg), np.cos(adeg)]] return np.matmul(x, rotation_matrix) def heighway(x, depth, col=&quot;black&quot;): if depth &gt; 1: x1 = rotate(x, -45) x1 = scale(x1, [np.sqrt(0.5), np.sqrt(0.5)]) heighway(x1, depth-1, col=&quot;blue&quot;) x2 = rotate(x, -45) x2 = scale(x2, [np.sqrt(0.5), np.sqrt(0.5)]) x2 = shift(x2, [0.75, 0.25]) heighway(x2, depth-1, col=&quot;red&quot;) else: plt.plot(x[0], x[1], marker=&#39;o&#39;, color=col, markersize=3) plt.figure() heighway([0,0], depth=14) plt.show() Wynik wykonania powyższych instrukcji 2.4.4 Drzewo Pitagorasa import numpy as np import matplotlib.pyplot as plt # Przesunięcie punktu x o wektor delta. def shift(x, delta): return np.add(x, delta) # Przeskalowanie punktu x razy ratio. def scale(x, ratio): return np.multiply(x, ratio) # Obrót o kąt alpha (w stopniach). def rotate(x, alpha): adeg = math.pi * alpha / 180 rotation_matrix = [ [np.cos(adeg), -np.sin(adeg)], [np.sin(adeg), np.cos(adeg)]] return np.matmul(x, rotation_matrix) def sbt(x, depth, col=&quot;black&quot;): if depth &gt; 1: x1 = rotate(x, -45) x1 = shift(scale(x1, [0.7, 0.7]), [0, 1]) sbt(x1, depth-1, col=&quot;blue&quot;) x2 = rotate(x, 45) x2 = shift(scale(x2, [0.7, 0.7]), [0, 1]) sbt(x2, depth-1, col=&quot;red&quot;) else: plt.plot(x[0], x[1], marker=&#39;o&#39;, color=col, markersize=3) plt.figure() sbt([0,0], depth = 14) plt.show() Wynik wykonania powyższych instrukcji 2.5 Przykłady w języku R Przykłady przedstawione w tym rozdziale powtarzają złożenie trzech atomowych transformacji – przesunięcia, przeskalowania i obrotu. Poniżej znajdują się definicje tych trzech transformacji. W tych przykładach x jest dwuelementowym wektorem. # Przesunięcie punktu x o delta. shift = function(x, delta) x + delta # Przeskalowanie punktu x razy ratio. scale = function(x, ratio) x * ratio # Obrót o kąt alpha (w stopniach). rotate = function(x, alpha) { sa = sin(pi * alpha / 180) ca = cos(pi * alpha / 180) x %*% matrix(c(ca, -sa, sa, ca), 2, 2, byrow = TRUE) } 2.5.1 Trójkąt Sierpińskiego Trójkąt Sierpińskiego składa się z trzech transformacji. \\[ y_1 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] \\] \\[ y_2 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.5 \\\\ 0 \\end{smallmatrix}\\right] \\] \\[ y_3 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.25 \\\\ \\sqrt3/4 \\end{smallmatrix}\\right] \\] Tak jak napisaliśmy na początku tego rozdziału, fraktale możemy budować ze zwykłych kropek, nie potrzebujemy bardziej wyrafinowanych poligonów. Przedstawmy to na bazie trójkąta Sierpińskiego. # Zapis x |&gt; scale(0.5) |&gt; shift(0.2) w języku R oznacza # ogonowe złożenie tych funkcji i jest równoważny zapisowi # shift(scale(x, 0.5), 0.2). Jest jednak czytelniejszy. sierpinski &lt;- function(x, depth, col = &quot;black&quot;) { if (depth &gt; 1) { x1 = x |&gt; scale(0.5) sierpinski(x1, depth - 1, col = &quot;blue&quot;) x2 = x |&gt; scale(0.5) |&gt; shift(c(0.5, 0)) sierpinski(x2, depth - 1, col = &quot;red&quot;) x3 = x |&gt; scale(0.5) |&gt; shift(c(0.25, 0.5)) sierpinski(x3, depth - 1, col = &quot;orange&quot;) } else { points(x[1], x[2], pch = 19, col = col, cex=0.3) } } plot.new() plot.window(xlim=c(0, 1), ylim=c(0,1), asp=1) sierpinski(c(0,0), depth = 8) Wynik wykonania powyższych instrukcji 2.5.2 Pięciokąt Sierpińskiego pentagon &lt;- function(x, depth, color=&quot;black&quot;) { if (depth &gt; 1) { x1 = x |&gt; scale(0.382) pentagon(x1, depth - 1, color = &quot;blue&quot;) x2 = x |&gt; scale(0.382) |&gt; shift(c(0.618, 0)) pentagon(x2, depth - 1, color = &quot;red&quot;) x3 = x |&gt; scale(0.382) |&gt; shift(c(0.809, 0.588)) pentagon(x3, depth - 1, color = &quot;green&quot;) x4 = x |&gt; scale(0.382) |&gt; shift(c(0.309, 0.951)) pentagon(x4, depth - 1, color = &quot;orange&quot;) x5 = x |&gt; scale(0.382) |&gt; shift(c(-0.191, 0.588)) pentagon(x5, depth - 1, color = &quot;pink&quot;) } else points(x[1], x[2], pch = 19, col = color, cex=0.5) } plot.new() plot.window(xlim=c(-0.5,1.5), ylim=c(-0.1,1.7), asp=1) pentagon(c(0,0), depth = 6) Wynik wykonania powyższych instrukcji 2.5.3 Smok Heighwaya heighway &lt;- function(x, depth, color=&quot;black&quot;) { if (depth &gt; 1) { x1 = x|&gt; rotate(45)|&gt; scale(sqrt(0.5))|&gt; shift(c(1,0)) heighway(x1, depth-1, color=&quot;blue&quot;) x2 = x|&gt; rotate(45)|&gt; scale(sqrt(0.5)) heighway(x2, depth-1, color=&quot;red&quot;) } else points(x[1], x[2], pch=19, col=color, cex=0.5) } plot.new() plot.window(xlim=c(-1,2), ylim=c(-1.5,0.5), asp=1) heighway(c(1,1), depth = 15) Wynik wykonania powyższych instrukcji 2.5.4 Symetryczne drzewo binarne / drzewo Pitagorasa pitagoras = function(x, depth, color=&quot;black&quot;) { if (depth &gt; 1) { x1 = x|&gt; rotate(-45) |&gt; scale(sqrt(0.5)) |&gt; shift(c(0,1)) pitagoras(x1, depth-1, color=&quot;blue&quot;) x2 = x|&gt; rotate(45) |&gt; scale(sqrt(0.5)) |&gt; shift(c(0,1)) pitagoras(x2, depth-1, color=&quot;red&quot;) } else points(x[1], x[2], pch=19, col=color, cex=0.5) } plot.new() plot.window(xlim = c(-3,3), ylim = c(0,3), asp=1) pitagoras(c(1,1), depth = 15) Wynik wykonania powyższych instrukcji 2.6 Przykłady w języku Julia 2.6.1 Trójkąt Sierpińskiego Fraktale możemy budować ze zwykłych kropek, nie potrzebujemy bardziej wyrafinowanych figur. Poniższy przykład z kropek buduje trójkąt Sierpińskiego. using Plots # Poniższy program powtarza złożenie funkcji sierpinski # depth razy. W teorii robilibyśmy to w nieskończoność, # ale do uzyskania wyraźnego obrazka wystarczy kilka kroków. # Liczba punktów rośnie wykładniczo, więc po k krokach wynosi 3^k. function sierpinski(x, y, depth) if depth &gt; 1 sierpinski(x/2, y/2, depth-1) sierpinski(x/2 + 0.5, y/2, depth-1) sierpinski(x/2 + 0.25, y/2 + 0.5, depth-1) else scatter!([x], [y], color=:black, legend=:false, markersize=2) end end # Inicjacja pustego wykresu i narysowanie trójkąta Sierpińskiego. plot(0, xlim=(-0.1,1.1), ylim=(-0.1,1.1), axis=nothing) sierpinski(0, 0, 9) Wynik wykonania powyższych instrukcji 2.6.2 Pięciokąt Sierpińskiego # Rekurencyjnie rysujemy każde z ramion pięciokąta. function pentagon(x, depth, col) if depth &gt; 1 x1 = 0.382x x2 = 0.382x + [0.618 0] x3 = 0.382x + [0.809 0.588] x4 = 0.382x + [0.309 0.951] x5 = 0.382x + [-0.191 0.588] pentagon(x1, depth-1, &quot;red&quot;) pentagon(x2, depth-1, &quot;blue&quot;) pentagon(x3, depth-1, &quot;green&quot;) pentagon(x4, depth-1, &quot;orange&quot;) pentagon(x5, depth-1, &quot;brown&quot;) else # Rysujemy jeden punkt po punkcie, przez co # tworzenie fraktala jest czasochłonne. # W kolejnym rozdziale zrobimy to lepiej. scatter!([x[1]], [x[2]], color=col, legend=:false, markersize=2) end end plot(0, xlim=(-0.35,1.35), ylim=(-0.1,1.6), axis=nothing) pentagon([0 0], 6, &quot;black&quot;) Wynik wykonania powyższych instrukcji 2.6.3 Smok Heighwaya W języku Julia dodawanie i skalowanie macierzy wykonuje się używając standardowych operatorów. Potrzebujemy zdefiniować funkcję dla obrotu wektora x o kąt \\(\\alpha\\). # Obrót o kąt alpha (w stopniach). function rotatex(x, alpha) sa = sin(pi * alpha / 180) ca = cos(pi * alpha / 180) [ca -sa; sa ca] * x end # Symbol &#39; oznacza transpozycje macierzy. # Potrzebujemy go by zamienić wektor wierszowy w kolumnowy. function heighway(x, depth, col) if depth &gt; 1 x1 = rotatex(x, -45) * sqrt(0.5) x2 = rotatex(x, -45) * sqrt(0.5) + [0.75 0.25]&#39; heighway(x1, depth-1, &quot;blue&quot;) heighway(x2, depth-1, &quot;red&quot;) else scatter!([x[1]], [x[2]], color=col, legend=:false, markersize=2) end end plot(0, xlim=(-0.5,1.5), ylim=(-1,0.5), axis=nothing) heighway([0 0]&#39;, 14, &quot;black&quot;) Wynik wykonania powyższych instrukcji 2.6.4 Drzewo Pitagorasa # Konstrukcja drzewa Pitagorasa jest bardzo podobna do # smoka Heighwaya. W ostatnim rozdziale pokażemy jak # płynnie przejść od jednego do drugiego. function sbt(x, depth, col) if depth &gt; 1 x1 = rotatex(x, -45) * 0.7 + [0 1]&#39; x2 = rotatex(x, 45) * 0.7 + [0 1]&#39; sbt(x1, depth-1, &quot;blue&quot;) sbt(x2, depth-1, &quot;red&quot;) else scatter!([x[1]], [x[2]], color =col, legend=:false, markersize = 2) end end plot(0, xlim=(-2,2), ylim=(0.5,3), axis=nothing) sbt([0 0]&#39;, 14, &quot;black&quot;) Wynik wykonania powyższych instrukcji Bibliografia "],["gra-w-chaos.html", "Rozdział 3 Gra w chaos", " Rozdział 3 Gra w chaos Część trzecia pojawi sie już wkrótce! "],["kieszonkowy-atlas-fraktali.html", "Rozdział 4 Kieszonkowy atlas fraktali", " Rozdział 4 Kieszonkowy atlas fraktali Część czwarta pojawi się już wkrótce! "],["bibliografia.html", "Bibliografia", " Bibliografia "]]

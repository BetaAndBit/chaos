[["index.html", "Gra w chaos Okładka", " Gra w chaos 2022-09-21 Okładka "],["jak-czytać-tę-książkę.html", "Jak czytać tę książkę? Podziękowania", " Jak czytać tę książkę? Fraktale to dziwaczne figury. Niby chaotyczne, ale opisane w zaskakująco uporządkowany sposób. Jednak aby dostrzec ten porządek, trzeba wiedzieć, na co patrzeć. Nasza podróż po krainie fraktali składa się z trzech części. Każda część ma swojego przewodnika, znakomitego polskiego matematyka, którego wyniki są związane z fraktalami. Pierwsza część skupiona jest głównie na konstrukcji trzech prostych fraktali. Uporządkujemy tutaj pewne kluczowe pojęcia niezbędne do zrozumienia dalszych rozdziałów. Przewodnikiem po niej jest genialny organizator – Wacław Sierpiński. Druga część pozwoli nam zagłębić się w matematyczne podstawy fraktali. Będą definicje i twierdzenia, z którymi zazwyczaj spotykają się studenci matematyki na pierwszym roku studiów. Kto mógłby lepiej zaopiekować się tą częścią niż genialny matematyk Stefan Banach? Trzeciej części patronuje Hugo Steinhaus, który bardzo interesował się zastosowaniami. Jest to więc wymarzony przewodnik po ciekawych zastosowaniach fraktali. Każda część zaczyna się od przedstawienia opiekuna, ponieważ matematyka to nie tylko wzory, ale też ludzie, którzy ją tworzą. O tej wymienionej powyżej trójce krążą legendy. Dlatego w każdej części znajduje się krótki komiks nawiązujący do ciekawego wydarzenia z ich życia. Następnie przedstawiona jest nowa metoda konstrukcji fraktali. Powinno to pobudzić apetyt matematyczny, który zaspokoić może wyłącznie formalne matematyczne przedstawienie, dlaczego dana metoda działa. Ostatni fragment każdej części to przykłady programów w językach R, Python i Julia pozwalające na odtworzenie omawianych fraktali. Na końcu książki znajduje się kieszonkowy atlas fraktali, z którymi zainteresowani czytelnicy mogą samodzielnie eksperymentować. Dlaczego fraktale? Ponad ćwierć wieku temu, kiedy byłem w drugiej klasie liceum, mój nauczyciel geometrii – profesor Wiesław Kostarczyk podrzucił mi książkę, która na nowo rozbudziła moje zainteresowanie matematyką. Były to Fraktale. Od geometrii do sztuki profesora Piotra Pierańskiego [Pier92]. Wtedy rozumiałem być może jedną piątą z tej książki, ale to wystarczyło, bym na lata zainteresował się tą tematyką. I co jakiś czas na nowo odkrywam związki z fraktalami w algorytmice, rachunku prawdopodobieństwa, topologii czy analizie funkcjonalnej. Kto wie, może, Drogi Czytelniku, ta książka rozbudzi też Twoje zainteresowanie tymi dziwacznymi obiektami. Podziękowania Ta książka nie powstałaby dzięki wielu osobom oraz instytucjom, które czasem pośrednio, a czasem bezpośrednio pomagało na rozmaitych etapach prac. Wszystkich wymienić nie sposób, ale muszę podziękować przynajmniej kilku osobom i instytucjom. Pierwsza wersja przykładowych kodów w językach Python i Julia powstała dzięki Krzysztofowi Trajkowskiemu, który wspiera mnie przy różnych inicjatywach od lat. Ilustracje w tej książce powstały dzięki Aleksandrowi Zawadzie, niesamowitemu projektantowi i grafikowi, który znalazł czas by uświetnić tę pozycje częścią komiksową z przygodami Bety i Bita. Ta książka jest jedną z trzech pozycji realizowanych przy wsparciu zadania ,,Komiksowa Matematyka’’ w projekcie MatFizChemPW — podnoszenie kompetencji matematyczno-przyrodniczych oraz ICT u młodzieży szkolonej. Projekt jest współfinansowany przez Unię Europejską ze środków Europejskiego Funduszu Społecznego w ramach Programu Wiedza Edukacja Rozwój 2014-2020. Bibliografia "],["witajcie-fraktale.html", "Rozdział 1 Witajcie, fraktale! 1.1 Wacław Sierpiński 1.2 Kurz Cantora 1.3 Trójkąt Sierpińskiego 1.4 Wymiar topologiczny 1.5 Wymiar Minkowskiego, czyli fraktalny wymiar pudełkowy 1.6 Dywan Sierpińskiego 1.7 Przykłady w języku Python 1.8 Przykłady w języku R 1.9 Przykłady w języku Julia", " Rozdział 1 Witajcie, fraktale! Rozdział, w którym poznajemy badacza nieskończoności oraz po raz pierwszy rysujemy dywan składający się prawie z samych dziur. Beta i Bit spotykają Wacława Sierpińskiego podczas wykładu w Krakowie W bazgrołach znudzonego Bita Wacław Sierpiński dostrzegł arcyciekawą figurę 1.1 Wacław Sierpiński Okres dwudziestolecia międzywojennego to nie tylko odradzająca się Polska, to też czas bardzo intensywnego rozwoju polskiej szkoły matematycznej. Główne ośrodki rozwoju tej szkoły w okresie międzywojennym to Warszawa, Lwów i Kraków. Czołowi matematycy tego czasu często podróżowali pomiędzy tymi miastami, inspirując się, wymieniając wiedzą i doświadczeniem. A gdy mówimy o czołowych matematykach, to nie sposób nie wspomnieć o Wacławie Sierpińskim, który tytuł magistra uzyskał w Warszawie, doktora w Krakowie, a habilitację zrobił we Lwowie. Czy może być lepsza data urodzenia dla matematyka niż 14 marca? Właśnie w tym dniu w 1882 roku w Warszawie urodził się nasz bohater. Na studia trafił na Cesarski Uniwersytet Warszawski, gdzie pod opieką Gieorgija Woronoja (tak, to ten Woronoj od diagramu Woronoja) zainteresował się teorią liczb, obronił tytuł kandydata nauk (odpowiednik dzisiejszego magistra) i zaczął uczyć matematyki w gimnazjum. Nie pracował tam długo. Jako bardzo aktywna osoba, brał udział w strajkach szkolnych, przez co stracił pracę. Przeniósł się więc do Krakowa, a na Uniwersytecie Jagiellońskim szybko zrobił doktorat, badając sumy szeregów \\(\\sum_{m^2+n^2 \\leq x}f(m^2+n^2)\\). Trzy lata później habilitował się już na Uniwersytecie Lwowskim. W tamtym okresie i przez resztę życia wiele podróżował po znakomitych ośrodkach matematycznych na całym świecie, między innymi studiował w Getyndze, gdzie spotkał matematyka Constantina Carathéodory’ego (przez pewien czas pracującego w Breslau, dzisiejszym Wrocławiu) czy Hugona Steinhausa (o którym piszemy więcej w rozdziale trzecim). Był świetnym organizatorem, biorącym udział w wielu inicjatywach. Przykładowo w roku 1920 wspólnie z Zygmuntem Janiszewskim i Stefanem Mazurkiewiczem założyli ,,Fundamenta Mathematicae’’ – pierwsze na świecie czasopismo poświęcone logice matematycznej, teorii mnogości oraz ich zastosowaniom. Sierpiński szybko dał się poznać jako świetny i bardzo wszechstronny matematyk. Gdy w 1920 roku Jan Kowalewski tworzył oddział łamania sowieckich szyfrów, zatrudnił Wacława Sierpińskiego razem ze Stefanem Mazurkiewiczem i Stanisławem Leśniewskim, aby sprawniej odszyfrowywać sowieckie depesze. Oddział ten był na tyle efektywny, że później przypisywano mu znaczny wkład w sukces Wojska Polskiego podczas wojny polsko-bolszewickiej, w tym pamiętnej Bitwy Warszawskiej. Biuro Szyfrów w tamtych czasach było bardzo innowacyjnym przedsięwzięciem, dość powiedzieć, że powstało 20 lat przed sławnym Bletchley Park. Sprawny nasłuch radiowy, możliwy dzięki elektronikom z politechnik, połączony z efektywną analizą kryptograficzną, możliwą dzięki matematykom z Uniwersytetu Warszawskiego i Lwowskiego, dał dowódcom wojskowym niezbędne dane o planach wojsk wroga. Krążyły wręcz anegdoty, że Biuro Szyfrów było w stanie odszyfrować depesze szybciej niż planowani odbiorcy. Sukcesy tego zespołu zbudowały podwaliny pod Biuro Szyfrów w Poznaniu, które dekadę później rozsławili łamacze Enigmy: Marian Rejewski, Jerzy Różycki i Henryk Zygalski. Przez lata Wacław Sierpiński uczył studentów w gimnazjach, wykładał na uniwersytetach, ale też pisał podręczniki. Wielu wydań doczekał się bardzo znany podręcznik do arytmetyki i geometrii, który napisał razem ze Stefanem Banachem i Włodzimierzem Stożkiem. Z uwagi na działalność związaną z nauczaniem został prezesem Towarzystwa Nauczycieli Szkół Średnich i Wyższych. Był też promotorem doktoratów wielu wybitnych matematyków, np. Jerzego Spławy-Neymana, Ottona Nikodyma, Kazimierza Kuratowskiego czy Alfreda Tarskiego. Sierpiński miał zatem liczne talenty, ale jego zainteresowania były głównie związane z prowadzeniem badań naukowych. Napisał łącznie 113 artykułów, nie sposób więc krótko streścić jego licznych wyników. Jego pasją było studiowanie nieskończoności, czy to w teorii liczb, analizie matematycznej, teorii mnogości, czy topologii. W roku 1915, w wieku 33 lat, podał sposób konstrukcji ciekawej figury, nazywanej później trójkątem Sierpińskiego. Powstaje ona jako wynik nieskończonego ciągu pewnych operacji. Jest to dziś jeden z najpopularniejszych fraktali, choć słowo pojęcie fraktala wprowadził dopiero Benedykt Mandelbrot 60 lat później, w roku 1975. Jego nagrobek można znaleźć na warszawskich Powązkach, a na nagrobku widnieje napis ,,Badacz nieskończoności’’. 1.2 Kurz Cantora To fascynujące, że powtarzanie w nieskończoność tych samych czynności może prowadzić do powstania arcyciekawych figur – fraktali. Taką figurę może narysować każdy, wystarczy podstawowa znajomość programowania. Krok po kroku pokażemy, jak skonstruować różne klasy fraktali. Znajomość podstaw algebry, prawdopodobieństwa lub topologii pozwala dokładniej zrozumieć, skąd się te zaskakujące figury biorą. Jedną z ciekawszych metod konstrukcji fraktali jest metoda ,,przez wygryzanie’’. Bierzemy pewną figurę, a następnie usuwamy z niej (wygryzamy) kawałki. To, co zostaje, jest fraktalem, często o zaskakujących właściwościach. Zilustrujmy to na przykładzie fraktala nazywanego kurzem Cantora (od nazwiska Georga Cantora, pioniera teorii mnogości). Receptura na konstrukcję kurzu Cantora. Weź odcinek o dowolnej długości (ale dla uproszczenia nasz będzie miał długość 1). Podziel ten odcinek na trzy równe części. Usuń wnętrze środkowej części, przez co otrzymasz dwa odcinki, oba o długości 1/3 wyjściowego odcinka. Dla każdego z otrzymanych odcinków kontynuuj dzielenie, idąc do kroku 2. Ilustracja pięciu kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 1. Rysunek 1: Pierwsze 5 iteracji w konstrukcji kurzu Cantora Powyższy algorytm cechuje kilka elementów typowych dla fraktali. Po pierwsze, nigdy się nie kończy, całą procedurę należy (przynajmniej w teorii) powtarzać nieskończenie wiele razy. Po drugie, mamy do czynienia z rekurencją. Trzeci krok prowadzi do powstania zbioru dwóch obiektów, a następnie każdy z nich jest ponownie przekształcany w taki sam sposób jak obiekt wyjściowy. Postępując bardzo podobnie, można otrzymać wiele ciekawych figur, ale przyjrzyjmy się jeszcze przez chwilę kurzowi Cantora. Zobaczmy, co my właściwie otrzymaliśmy w wyniku tej procedury. Sprawdźmy może, jak duży jest ten obiekt, czyli jaką ma długość. Początkowo odcinek miał długość \\(1\\), ale w pierwszym kroku usunęliśmy \\(1/3\\). W drugim kroku usunęliśmy \\(2\\) razy po \\((1/3)^2\\). Powtarzając to kilkukrotnie, w kroku \\(k\\) usuwamy \\(2^{k-1}\\) odcinków, każdy o długości \\((1/3)^k\\). A więc długość tego tworu w kroku \\(k\\) to: \\[\\begin{equation} \\begin{split} 1 &amp;- 1/3 - 2*(1/3)^2 - ... - 2^{k-1}*(1/3)^k = \\\\ &amp; 1 - \\sum_{i=1}^k 2^{i-1}*(1/3)^i = 1 - 1/2 \\sum_{i=1}^k (2/3)^i = \\\\ &amp; 1 - \\frac 12 (2 - 2 (2/3^k)) = (2/3)^k \\xrightarrow[k\\rightarrow \\infty]{} 0 \\end{split} \\end{equation}\\] Do tego samego wniosku można dojść, stosując inne rozumowanie, a mianowicie patrząc, ile zostało z odcinka po \\(k\\)-tym kroku. Po pierwszym kroku mamy \\(2\\) odcinki długości \\(1/3\\), po drugim kroku mamy \\(2^2\\) odcinków długości \\((1/3)^2\\), a po kroku \\(k\\) mamy \\(2^k\\) odcinków o długości \\((1/3)^k\\). Do czego zbiega ten ciąg? \\[ \\lim_{k \\rightarrow \\infty} (2/3)^k = 0 \\] Nie ma więc wątpliwości. Zbiór Cantora ma długość równą \\(0\\). Ale ewidentnie nie jest zbiorem pustym, bo ma wiele punktów. Jak wiele? Okazuje się, że tyle samo co cały odcinek, a więc nieprzeliczalnie wiele. Pokażmy to za pomocą pewnego sprytnego dowodu. Twierdzenie (liczność zbioru Cantora). Zbiór Cantora jest równoliczny z odcinkiem \\([0, 1]\\). Dowód: Aby policzyć punkty w zbiorze Cantora, musimy dla każdego punktu skonstruować rodowód, a więc zapis pozwalający jednoznacznie zidentyfikować każdy punkt. Rodowodem jednoznacznie identyfikującym punkt nazwiemy zbiór decyzji określających, jak do tego punktu dotrzeć w kolejnych krokach procedury generującej kurz Cantora. Pamiętamy, że w każdym kroku usuwane są środki z odcinków, więc punkt, który należy do kurzu Cantora, będzie leżał albo w lewym albo w prawym odcinku. Ten wybór (lewy/prawy) trzeba podjąć w każdym kroku konstrukcji kurzu. Taki rodowód możemy zapisać przez nieskończoną sekwencję cyfr 0/1 – jeżeli w sekwencji na pozycji \\(k\\) występuje 0, to punkt należy do lewego pododcinka, jeżeli 1, to do prawego. Zauważmy jednoznaczność -&gt; każdy punkt z kurzu Cantora może być opisany przez nieskończoną sekwencję cyfr 0/1. Jednocześnie każda nieskończona sekwencja cyfr opisuje jakiś punkt ze zbioru Cantora, a różne sekwencje opisują różne punkty. Ile jest takich sekwencji? Tyle samo co w całym odcinku. Wystarczy bowiem myśleć o tych sekwencjach jak o rozwinięciach dwójkowych liczb z przedziału \\([0, 1]\\). ∎ Co więc mamy? Kurz Cantora ma tyle samo punktów co odcinek \\([0, 1]\\). Ale jednocześnie ma długość 0, choć odcinek ma oczywiście długość 1. Jak to możliwe? To jedna z wielu zagadek kryjących się w krainie fraktali malowanych nieskończonością. 1.3 Trójkąt Sierpińskiego Jeden z najbardziej znanych fraktali to z pewnością trójkąt Sierpińskiego, którego konstrukcja jest dosyć podobna do metody tworzenia kurzu Cantora. Receptura na konstrukcję trójkąta Sierpińskiego. Weź trójkąt równoboczny o dowolnej wielkości. Podziel ten trójkąt na cztery trójkąty równoboczne. Usuń wnętrze środkowego trójkąta, przez co otrzymasz trzy trójkąty z brzegiem, wszystkie o wielkości boku 1/2 wyjściowego trójkąta. Dla każdego z trzech otrzymanych trójkątów kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 2. Rysunek 2: Pierwsze cztery iteracje w konstrukcji trójkąta Sierpińskiego Ładny to twór. Ale jakie ma właściwości? Jakie ma pole? Szybkie rachunki pozwalają rozwiać wszelkie wątpliwości. W kroku \\(k\\) trójkąt składa się z \\(3^k\\) trójkątów, każdy o boku \\(1/2^k\\), czyli polu \\(\\sqrt{3}/2^{2k+1}\\). Łączne pole tego, co pozostało po kroku \\(k\\), to \\((3/4)^k \\cdot \\sqrt{3}/2\\). W granicy mamy: \\[ \\lim_{k \\rightarrow \\infty} (3/4)^k \\cdot \\sqrt{3}/2 = 0. \\] Trójkąt Sierpińskiego jest zatem tak dziurawy, że ma pole równe 0. A jak długi jest jego brzeg? W kroku \\(k\\) brzeg zwiększa się o \\(3^{k-1}\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli obwodzie \\(3 \\cdot (1/2)^k\\). Łączny brzeg w kroku \\(k\\) to: \\[ \\sum_{i=1}^k 3^{k-1} \\cdot 3 \\cdot (1/2)^k = \\sum_{i=1}^k (3/2)^k. \\] Elementy tej sumy rosną do nieskończoności, więc tym bardziej cały brzeg trójkąta eksploduje do nieskończoności: \\[ \\lim_{k \\rightarrow \\infty}\\sum_{i=1}^k (3/2)^k = \\infty. \\] Co to za figura? Jest ograniczona, bo mieści się w trójkącie o boku 1, ale ma nieskończony obwód przy zerowym polu. Z jakiego to jest wymiaru? Prawdopodobnie do tego miejsca część czytelników zadaje sobie pytanie, czym są fraktale. Czy są to takie dziwne obrazki? A jeżeli tak, to jak je scharakteryzować? Jedną z częściej powtarzanych definicji fraktali jest definicja podana przez Mandelbrota, którą sparafrazuję do: Definicja (fraktal). Fraktalem nazywamy taki zbiór, którego wymiar fraktalny jest wyższy niż wymiar topologiczny. Jak się zaraz okaże, często wymiar fraktalny nie musi być liczbą całkowitą, stąd też nazwa fraktal, od francuskiego fractus oraz łacińskiego frangěre – złamać, postrzępić, cząstkowy. Ale czym jest ten wymiar topologiczny i fraktalny? 1.4 Wymiar topologiczny Gdy myślimy o przestrzeniach euklidesowych, wymiarem określa się liczbę prostopadłych kierunków rozpinających daną przestrzeń. Punkt w związku z tym ma wymiar 0, prosta ma wymiar 1, płaszczyzna ma wymiar 2, a wszyscy doświadczamy trójwymiarowej przestrzeni. Pewne obiekty możemy opisywać w przestrzeniach o wyższych wymiarach i nie ma tu żadnych ograniczeń. Matematyk z podekscytowaniem w głosie może opowiadać o przestrzeni funkcji, która jest nieskończenie wymiarowa. Podobnie możemy myśleć o wymiarach zbiorów. Intuicyjnie wymiarem zbioru będzie liczba prostopadłych odcinków, które można w tym zbiorze zmieścić. Należy jednak być ostrożnym. Niby wszystko się zgadza, punkt ma wymiar 0, odcinek ma wymiar 1, kwadrat ma wymiar 2, sześcian ma wymiar 3 i tak dalej. Jednak co zrobić z okręgiem? Nie mieści się w nim żaden odcinek. Ale przecież powinien mieć wymiar większy niż 0, bo to taki sklejony odcinek. Więc najlepiej, aby też miał wymiar 1. Sprawa jest więc trudniejsza. Matematycy głowili się nad nią długo, a formalna definicja wymiaru dla zbiorów jest dosyć młoda. Pierwsza indukcyjna definicja została zaproponowana niecałe 100 lat temu niezależnie przez Pawła Urysona i Karla Mengera (lata 1922–1923). Dzisiaj mamy różnych definicji wymiaru przynajmniej kilka. Zainteresowani znajdą je wraz z wieloma ciekawostkami w artykule Kilka słów o wymiarze [Nowa11]. Na potrzeby dalszego wywodu pozostaniemy przy intuicyjnej definicji – z liczbą prostopadłych odcinków, które można zanurzyć w analizowany zbiór. 1.5 Wymiar Minkowskiego, czyli fraktalny wymiar pudełkowy Definicji wymiaru fraktalnego jest też kilka, ale prawdopodobnie najpopularniejsza jest definicja Minkowskiego, nazywana często wymiarem pudełkowym. Określa się go dla obiektów geometrycznych zanurzonych w zwykłych \\(p\\)-wymiarowych przestrzeniach (my ograniczymy się praktycznie wyłącznie do \\(p=2\\)). Aby go wyznaczyć, musimy policzyć iloma \\(p\\)-wymiarowymi pudełkami o boku \\(\\varepsilon\\) można przykryć interesujący nas obiekt. Mandelbrot, pisząc o wymiarze fraktalnym, odnosił się do definicji wymiaru Hausdorffa, który jest uogólnieniem wymiaru Minkowskiego. W definicji Hausdorffa zamiast równymi pudełkami możemy analizowany obiekt przykrywać dowolną rodziną zbiorów o średnicach zbiegających do 0. Jeżeli przez \\(N(\\varepsilon)\\) określimy minimalną liczbę pudełek o boku \\(\\varepsilon\\) pokrywających obiekt \\(F\\), to wymiarem pudełkowym \\(d_F\\) tego obiektu jest: \\[ d_F = \\lim_{\\varepsilon \\rightarrow 0} \\frac{\\log N(\\varepsilon)}{\\log 1/\\varepsilon}. \\] W ogólności ta granica może nie istnieć. W takich sytuacjach osobno można rozważać kres górny i dolny tego ciągu. Ale dla obiektów przedstawionych w tej książce tak zdefiniowana granica zawsze do czegoś zbiega. Co więcej, nie ma znaczenia, jakiej wielkości pudełka wybieramy. Przykłady pokazuję dla pudełek, które ,,szczelnie’’ zakrywają fragmenty badanej figury, tak by ułatwić sobie obliczenia. Przyjmijmy na razie, że interesują nas pudełka o boku \\(\\varepsilon = 2^{-k}\\). Jeżeli chcemy przykryć nimi kwadrat o boku \\(1\\), to potrzebujemy ich przynajmniej \\(N(\\varepsilon) = 2^k * 2^k = 2^{2k}\\). Wymiar pudełkowy kwadratu to zatem: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{2k}}{\\log 1/2^{-k}} = 2. \\] A co z trójkątem Sierpińskiego? Tutaj wystarczy nam \\(N(\\varepsilon) = 3^k\\) kostek o boku \\(2^{-k}\\), a więc wymiar pudełkowy dla tego trójkąta to: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 3^{k}}{\\log 1/2^{-k}} = \\frac{\\log 3}{\\log 2} = 1,5849\\ldots \\] Rysunek 3 ilustruje, jak wygląda przykładowe pokrycie trójkąta Sierpińskiego kostkami o boku 1/4 i 1/8. Rysunek 3: Pokrycie trójkąta Sierpińskiego kostkami o boku 1/4 (lewy panel) i 1/8 (prawy panel) Jaki jest wymiar kurzu Cantora? Tym razem mamy obiekt zanurzony w przestrzeni jednowymiarowej, więc będziemy go przykrywać odcinkami. Przyjmijmy, że mamy odcinki o długości \\(\\varepsilon = 3^{-k}\\). Aby pokryć cały kurz Cantora wystarczy nam takich odcinków \\(N(\\varepsilon) = 2^k\\), czyli wymiar pudełkowy dla kurzu Cantora: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{k}}{\\log 1/3^{-k}} = \\frac{\\log 2}{\\log 3} = 0,6309\\ldots \\] BK: Niezwykłe jest to, że wymiar zbioru Cantora, którego wszystkie składowe są jednopunktowe (więc ma topologiczny wymiar 0), ma wymiar pudełkowy ostro większy od 0, i w dodatku ułamkowy. 1.6 Dywan Sierpińskiego Wiemy już, czym charakteryzują się fraktale, czas poznać kolejnych przedstawicieli tej niesamowitej rodziny. Bardzo znanym jej reprezentantem jest dywan Sierpińskiego. Receptura na konstrukcję dywanu Sierpińskiego. Weź kwadrat o dowolnej wielkości. Podziel ten kwadrat na dziewięć kwadratów. Usuń wnętrze środkowego kwadratu, otrzymasz osiem kwadratów o boku 1/3 wyjściowego kwadratu. Dla każdego z otrzymanych ośmiu kwadratów kontynuuj dzielenie, idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 4. Rysunek 4: Pierwsze cztery iteracje w konstrukcji dywanu Sierpińskiego Jaki jest wymiar pudełkowy tego tworu? Weźmy kostki o wielkości \\(\\varepsilon = 3^{-k}\\). Do zakrycia dywanu wystarczy nam \\(N(\\varepsilon) = 8^k\\) pudełek o boku \\(3^{-k}\\). Tak więc wymiar pudełkowy tego dywanu to: \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 8^{k}}{\\log 1/3^{-k}} = \\frac{\\log 8}{\\log 3} = 1,8927... \\] 1.7 Przykłady w języku Python W tym rozdziale przedstawiamy przykłady kodu w programie Python, które pozwalają na narysowanie kolejnych przybliżeń Kurzu Cantora, Trójkąta Sierpińskiego i Dywanu Sierpińskiego. Każdy może opisywane fraktale odtworzyć na własnym komputerze. W tym celu można zainstalować interpreter języka Python. Kody generujące fraktale są krótkie i ich zrozumienie jest możliwe bez wcześniejszej znajomości tego języka, choć oczywiście warto ten język poznać. Kilka informacji, które pomogą w zrozumieniu kodów: Poniższe przykłady korzystają z biblioteki matplotlib, w której znajdują się funkcje do rysowania, jak np. funkcja plot() do rysowania odcinka oraz fill() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. Funkcja figure() tworzy pusty wykres, a show() wyświetla go na ekranie. Bardziej złożone funkcje matematyczne znajdują się w bibliotece math. W tych przykładach wykorzystamy ją, aby użyć funkcji pierwiastka kwadratowego sqrt(). W bibliotece numpy znajdują się funkcje do operacji na wektorach i macierzach. Wykorzystamy ją, by uprościć zapis operacji na dwuelementowych wektorach – współrzędnych punktów. W wielu miejscach korzystamy z rekurencji, a więc sytuacji, gdy funkcja wywołuje samą siebie. Nowe funkcje definiuje się z użyciem słowa kluczowego def. Jednym z argumentów przedstawionych funkcji rekurencyjnych jest depth – określa, ile razy funkcja ma się rekurencyjnie wywołać. 1.7.1 Kurz Cantora Rysowanie kurzu Cantora oprzemy na rekurencyjnej funkcji dust, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – wielkość fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Niezbędne biblioteki. import matplotlib.pyplot as plt import numpy as np # Jeżeli depth=1 to rysujemy odcinek, jeżeli depth&gt;1, # to rysujemy dwa małe kurze Cantora obok siebie. def dust(x, scale, depth): if depth &gt; 1: dust(x, scale / 3, depth - 1) dust(x + scale*2/3, scale / 3, depth - 1) else: plt.plot([x, x+scale], [0,0], color = &quot;black&quot;) # Inicjacja rysunku i narysowanie kurzu o głębokości 5. plt.figure() dust(0, scale = 1, depth = 5) plt.show() Wynik wykonania powyższych instrukcji 1.7.2 Trójkąt Sierpińskiego Czas na kultowy trójkąt. Aby go narysować, wykorzystamy rekurencyjną funkcję sierpinski, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informacje o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Wczytujemy niezbędne biblioteki. import matplotlib.pyplot as plt import numpy as np import math # Definiujemy funkcję rysującą trójkąt zaczepiony # w punkcie x o boku scale. def triangle(x, scale): plt.fill([x[0], x[0]+scale, x[0]+scale/2], [x[1], x[1], x[1]+scale*np.sqrt(3)/2], color = &quot;black&quot;) # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy zwykły trójkąt, jeżeli depth&gt;1, # to rysujemy trzy trójkąty obok siebie. def sierpinski(x, scale, depth): if depth &gt; 1: sierpinski(x, scale/2, depth-1) sierpinski(np.add(x, [scale/2, 0]), scale/2, depth-1) sierpinski(np.add(x,[scale/4,scale*np.sqrt(3)/4]), scale/2, depth-1) else: triangle(x, scale) # Inicjacja rysunku i narysowanie trójkąta o głębokości 4. plt.figure() sierpinski([0,0], scale = 1, depth = 4) plt.show() Wynik wykonania powyższych instrukcji 1.7.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów, np. dla kwadratu lub pięciokąta. Poniżej przykład dla kwadratu z dziurką, czyli dywanu Sierpińskiego. import matplotlib.pyplot as plt import numpy as np # Rekurencyjna funkcja do rysowania dywanu Sierpińskiego. # Jeżeli depth=1, to rysujemy kwadrat, używając funkcji square(), # jeżeli depth&gt;1, to rysujemy osiem fraktali obok siebie. def square(x, scale): plt.fill(np.add(x[0], [0, scale, scale, 0]), np.add(x[1], [0 0, scale,scale]), color=&quot;black&quot;) def carpet(x, scale, depth): if depth &gt; 1: carpet(x, scale/3, depth-1) carpet(np.add(x, [scale/3,0]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,0]), scale/3,depth-1) carpet(np.add(x, [0,scale/3]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,scale/3]), scale/3,depth-1) carpet(np.add(x, [0,2*scale/3]), scale/3,depth-1) carpet(np.add(x, [scale/3,2*scale/3]), scale/3,depth-1) carpet(np.add(x, [2*scale/3,2*scale/3]), scale/3,depth-1) else: square(x, scale) plt.figure() carpet([0,0], scale = 1, depth = 4) plt.show() Wynik wykonania powyższych instrukcji 1.8 Przykłady w języku R Drogi Czytelniku, możesz opisywane fraktale odtworzyć na swoim komputerze, wystarczy tylko zainstalowany interpreter języka R, który można bezpłatnie pobrać i zainstalować ze strony [https://cran.r-project.org/]. Nie jest niezbędna wcześniejsza znajomość tego języka, choć oczywiście byłaby przydatna. Poniżej kilka informacji, które pomogą w zrozumieniu tego kodu. Poniższe przykłady korzystają z podstawowej biblioteki graficznej dla R, czyli graphics. Nie trzeba jej wczytywać, ponieważ jest dostępna od razu po uruchomieniu R. Funkcja plot.new() tworzy pusty wykres. Jest on wypełniany przez użycie funkcji polygon() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. R to język dla matematyków i statystyków, więc większość operacji matematycznych jest dostępna od razu po uruchomieniu konsoli, tak jak funkcja sqrt() potrzebna do wyliczenia wysokości trójkąta równobocznego. Program R działa natywnie na wektorach, co znaczy, że możemy używać arytmetycznych operatorów takich jak + czy / zarówno do liczb, jak i do wektorów. Aby kod był bardziej czytelny, korzystamy z rekurencji, a więc konstrukcji, w której funkcja sama się wywołuje. Nowe funkcje definiuje się z użyciem słowa kluczowego function. Przedstawione funkcje mają argument depth, określający, ile jeszcze razy funkcja ma wywołać samą siebie. 1.8.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informację o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Rekurencyjna funkcja do rysowania kurzu. Jeżeli depth=1 # to rysuje odcinek, jeżeli depth&gt;1 to rysujemy dwa # kurze Cantora obok siebie. dust = function(x, y, scale, depth = 1) { if (depth == 0) { lines(c(x, x + scale), c(y, y)) } else { dust(x, y, scale/3, depth - 1) dust(x + scale*2/3, y, scale/3, depth - 1) } } # Czyścimy ekran i zaczynamy rysowanie kurzu. plot.new() dust(0, 0, scale = 1, depth = 4) Wynik wykonania powyższych instrukcji 1.8.2 Trójkąt Sierpińskiego Czas na kultowy trójkąt Sierpińskiego. Aby go narysować, wykorzystamy rekurencyjną funkcję sierpinski(), która przyjmuje trzy argumenty: x – miejsce, od którego należy rysować fraktal, scale – informację o wielkości fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. triangle &lt;- function(x, y, scale) { polygon(x + scale*c(0, 1, 1/2), y + scale*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy trójkąt, używając funkcji triangle(), # jeżeli depth&gt;1, to rysujemy trzy trójkąty obok siebie. sierpinski &lt;- function(x, y, scale, depth = 1) { if (depth == 0) { triangle(x, y, scale) } else { sierpinski(x, y, scale/2, depth-1) sierpinski(x+scale/2, y, scale/2, depth-1) sierpinski(x+scale/4, y+sqrt(3)*scale/4,scale/2,depth-1) } } plot.new() sierpinski(0, 0, scale = 1, depth = 6) Wynik wykonania powyższych instrukcji 1.8.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów. # Rekurencyjna funkcja do rysowania dywanu. # W zależności od aktualnej głębokości albo rysuje kwadrat # albo, rekurencyjnie ośmiokrotnie wywołuje samą siebie carpet = function(x, y, scale, depth = 1) { if (depth == 1) { rect(x, y, x + scale, y + scale, col = &quot;black&quot;) } else { carpet(x, y, scale/3, depth - 1) carpet(x+scale*1/3, y, scale/3, depth - 1) carpet(x+scale*2/3, y, scale/3, depth - 1) carpet(x, y+scale*1/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*1/3, scale/3, depth - 1) carpet(x, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*1/3, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*2/3, scale/3, depth - 1) } } plot.new() carpet(0, 0, scale = 1, depth = 4) Wynik wykonania powyższych instrukcji 1.9 Przykłady w języku Julia Tworząc fraktale pewne operacje musimy powtarzać w nieskończoność, lub przynajmniej bardzo długo. Świetnie się do tego nadają wydajne, elastyczne i bardzo bardzo szybkie języki programowania. Takim właśnie językiem jest Julia. Interpreter tego języka i dokumentację można pobrać ze strony [https://julialang.org/]. Poniżej prezentujemy kilka informacji, które pomogą w zrozumieniu kolejnych przykładów. Poniższe przykłady korzystają z biblioteki Plots, podstawowej biblioteki dla języka Julia. Funkcja plot() z tej biblioteki tworzy pusty wykres. Można do niego dorysować kolejne figury funkcją plot!(). W poniższych przykładach tak będziemy tworzyć dodatkowe wypełnione wielokąty, trójkąty i kwadraty. Julia to język bardzo przyjazny operacjom matematycznym, można bez dodatkowych modułów korzystać z funkcji matematycznych, takich jak sqrt(). Operatory arytmetyczne takie jak + czy / działają zarówno dla liczb jak i dla wektorów. Aby kod był bardziej czytelny korzystamy z rekurencji, a więc konstrukcji, w której funkcja, sama się wywołuje. Nowe funkcje definiuje się z użyciem słowa function. W przypadku krótszych funkcji można stosować uproszczoną definicje z operatorem =. Z krótszego sposobu skorzystamy definiując funkcje line, triangle, square. 1.9.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od Kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x – początek fraktala, scale – wielkość fraktala oraz depth – aktualny poziom zagnieżdżenia fraktala. # Pakiet z funkcjami graficznymi. using Plots # Funkcja definiująca odcinek. line(x, scale) = Shape([x, x+scale], [0, 0]) # Rekurencyjna funkcja do rysowania kurzu. # Jeżeli depth=1, to rysujemy odcinek, jeżeli depth&gt;1, # to rysujemy dwa kurze Cantora obok siebie. function dust(x, scale, depth=1) if depth == 0 plot!(line(x, scale), color=:black, legend=:false) else dust(x, scale/3, depth - 1) dust(x + scale*2/3, scale/3, depth-1) end end # Czyścimy ekran i zaczynamy rysowanie kurzu. plot(0, xlim=(-0.1,1.1), ylim=(-0.1,0.1), axis=nothing) dust(0.0, 1.0, 4) Wynik wykonania powyższych instrukcji 1.9.2 Trójkąt Sierpińskiego Wynik wykonania powyższych instrukcji Czas na kultowy trójkąt Sierpińskiego. Aby go narysować wykorzystamy rekurencyjną funkcję sierpinski(), która przyjmuje trzy argumenty: x, y – miejsce od którego należy rysować fraktal, scale – wielkość fraktalu oraz depth aktualny poziom zagnieżdżenia fraktala. triangle(x, y, scale) = Shape([x, x+scale, x+scale/2, x], [y, y, y+scale*sqrt(3)/2, y]) # Rekurencyjna funkcja do rysowania trójkąta Sierpińskiego. # Jeżeli depth=1, to rysujemy trójkąt używając funkcji triangle(), # jeżeli depth&gt;1. to rysujemy trzy trójkąty Sierpińskiego. function sierpinski(x, y, scale, depth=1) if depth==0 plot!(triangle(x,y,scale),color=:black,legend=:false) else sierpinski(x, y, scale/2, depth-1) sierpinski(x+scale/2, y, scale/2, depth-1) sierpinski(x+scale/4,y+sqrt(3)*scale/4,scale/2,depth-1) end end plot(0, xlim=(0,1), ylim=(0,1), axis=nothing) sierpinski(0, 0, 1, 6) Wynik wykonania powyższych instrukcji 1.9.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów. square(x, y, w) = Shape([x, x+w, x+w, x], [y, y, y+w, y+w]) # Wykorzystujemy funkcje square zdefiniowaną powyżej aby narysować kwadrat. function carpet(x, y, scale, depth=1) if depth==0 plot!(square(x,y,scale), color=:black, legend=:false) else carpet(x, y, scale/3, depth-1) carpet(x, y+scale, scale/3, depth-1) carpet(x, y+2scale, scale/3, depth-1) carpet(x+scale, y, scale/3, depth-1) carpet(x+scale, y+2scale, scale/3, depth-1) carpet(x+2scale, y, scale/3, depth-1) carpet(x+2scale, y+scale, scale/3, depth-1) carpet(x+2scale, y+2scale, scale/3, depth-1) end end plot(0, xlim=(0,3), ylim=(0,3), axis=nothing) carpet(0.0, 0.0, 1.0, 5) Wynik wykonania powyższych instrukcji Bibliografia "],["fraktal-czyli-punkt-stały.html", "Rozdział 2 Fraktal, czyli punkt stały", " Rozdział 2 Fraktal, czyli punkt stały Część druga pojawi sie już wkrótce! "],["gra-w-chaos.html", "Rozdział 3 Gra w chaos", " Rozdział 3 Gra w chaos Część trzecia pojawi sie już wkrótce! "],["kieszonkowy-atlas-fraktali.html", "Rozdział 4 Kieszonkowy atlas fraktali", " Rozdział 4 Kieszonkowy atlas fraktali Część czwarta pojawi się już wkrótce! "],["bibliografia.html", "Bibliografia", " Bibliografia "]]

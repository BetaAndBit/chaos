[["index.html", "Gra w chaos z przykładami w języku matematyki, R, Python i Julia 0.1 Wprowadzenie 0.2 Jak czytać tę książkę", " Gra w chaos 2022-07-23 z przykładami w języku matematyki, R, Python i Julia 0.1 Wprowadzenie Ponad ćwierć wieku temu, w drugiej klasie liceum, mój nauczyciel geometrii - prof. Wiesław Kostarczyk podrzucił mi książkę, która na nowo rozbudziła moje zainteresowanie matematyką. Były to ,,Fraktale od geometrii do sztuki’’ prof. Piotra Pierańskiego. Wtedy rozumiałem być może jedną piątą z tej książki, ale to wystarczyło. Krzywa, która jest tak gęsto upakowana w kwadracie, że choć ma zerowe pole to każdy niezerowy kwadracik zawiera jej kawałek? Dwa równoliczne zbiory, z których jeden na długość 0 a drugi długość 1? Paradoks za paradoksem. Pięć lat później znów trafiłem na fraktale, tym razem podczas studiów informatycznych. Okazało się, że te ciekawe figury mają nie tylko interesujące właściwości matematyczne, ale też bardzo ciekawą konstrukcje którą można zaprogramować! Ech, ile czasu spędziłem na wyszukiwaniu i oprogramowaniu różnych wariantów fraktali (a były to czasy raczkującego Internetu, więc trudno było znaleźć ciekawe konstrukcje, trzeba było głęboko kopać). Gdy 4 lata temu zacząłem pracować nad nowym programem ,,Matematyka Komiksowa’’, który miał na celu pokazać z użyciem komiksu ciekawe wyniki łączące matematyką i informatykę nie miałem wątpliwości! Musiałem napisać historię związaną z fraktalami. Chciałem też by była to wyjątkowa pozycja pokazująca fraktale z wielu perspektyw, ponieważ nigdy nie wiadomo która perspektywa okaże się najbardziej wciągająca. W tej książce znajdziecie urywki z życia trzech wielkich polskich matematyków związanych z fraktalami - Wacława Sierpińskiego, Stefana Banacha i Hugona Steinhausa. Z wyjątkiem pierwszego nie pracowali oni bezpośrednio nad fraktalami, ale jak się okazuje ich wyniki pomagają zrozumieć naturę tych figur. Historie te są pokazane przez krótkie komiksowe historyjki, mam nadzieję, że zainteresują one niektórych czytelników do sięgnięcia głębiej do ich życiorysów. Oczywiście nie mogło zabraknąć przedstawienia wybranych - istotnych twierdzeń - opisujących prawidła rządzące światem fraktali. Starałem się unikać terminologii wykraczającej poza słownik zainteresowanego matematyką licealisty. Mam nadzieję, że to zubożenie słownika zostanie mi wybaczone również przez kolegów matematyków. Zależało mi też na tym by przedstawić w tej książce też dokładne przepisy jak fraktale odtworzyć w zaciszu własnego komputera. Mamy więc programy rysujące fraktale w językach R, Python i Julia. Pisanie tej książki pozwoliło mi na nowo przeżyć ekscytacje sprzed lat bawiąc się w generowanie dziwnych figur. Mam nadzieję, że choć część tych emocji udzieli się też Tobie, drogi czytelniku. Przemysław Biecek, Wilga 2022. 0.2 Jak czytać tę książkę Fraktale to dziwaczne struktury, niby przypadkowe, ale opisane w zaskakująco uporządkowany sposób. Podobnie jest z tą książką. Nasza podróż po krainie fraktali składa się z trzech części o pewnej strukturze. Każda część ma swojego opiekuna / przewodnika. Styl części różni się w zależności od tego kim jest opiekun. Pierwsza część skupiona jest głównie na konstrukcji pewnych tworów i oprowadzi nas po niej Wacław Sierpiński, który był genialnym organizatorem. Druga część przeprowadzi nas po podstawach matematycznych fraktali. Będzie sporo definicji i twierdzeń z którymi zazwyczaj spotykają się studenci matematyki na pierwszym roku. Kto mógłby lepiej zaopiekować się tą częścią niż genialny matematyk Stefan Banach? Trzecią częścią zaopiekuje się Hugo Steinhaus, który bardzo interesował się zastosowaniami. Jest to więc wymarzony przewodnik po ciekawych zastosowaniach systemów funkcji iterowanych. Również każda z części ma wewnętrzną strukturę, którą powtórzymy trzykrotnie. Zaczniemy od przedstawienia naszego opiekuna, ponieważ matematyka to nie tylko wzory, ale też ludzie, którzy je tworzą. Następnie zilustrujemy jedną scenkę z życia opiekuna, która łączy do z tematem fraktali. Niektóre z tych scenek mają na tyle historyczne znaczenie, że doczekały się pomników. Kolejny krok to przedstawienie metody konstrukcji określonego rodzaju fraktali, będą to głównie algorytmy pokazując jak zrobić dany fraktal. Powinno to pobudzić apetyt matematyczny, który zaspokoić może wyłącznie formalne matematyczne przedstawienie, dlaczego dany fraktal działa. Matematycy mówią na takie części ,,część z gwiazdką’’. Powinna być interesującym uzupełnieniem informacji dla osób lubiących kopać głęboko, ale można też je pominąć przy pierwszym czytaniu. Ostatnia fragment każdej części to przykłady programów w językach R, Python i Julia. Można te przykłady wykorzystać, aby samemu na własnym komputerze odtworzyć przedstawiane fraktale. Na końcu książki zostawiamy kilka zadań do samodzielnego wykonania dla szczególnie zainteresowanych czytelników. "],["misja-pierwsza.html", "Rozdział 1 Misja pierwsza 1.1 Wacław Sierpiński 1.2 Witajcie fraktale! 1.3 Przykłady w Python 1.4 Przykłady w R", " Rozdział 1 Misja pierwsza Misja, w której poznajemy badacza nieskończoności oraz po raz pierwszy rysujemy dywan składający się prawie z samych dziur. 1.1 Wacław Sierpiński Okres dwudziestolecia międzywojennego to nie tylko odradzająca się Polska, to też okres bardzo intensywnego rozwoju Polskiej Szkoły Matematycznej. Główne ośrodki rozwoju tej szkoły w okresie międzywojennym to Warszawa, Lwów i Kraków. Czołowi matematycy tego czasu często poróżowali pomiędzy nimi, inspirując się, wymieniając wiedzą i doświadczeniem. A gdy mówimy o czołowych matematykach, to nie sposób nie wspomnieć o Wacławie Sierpińskim, który tytuł magistra uzyskał w Warszawie, doktora w Krakowie a habilitacje zrobił we Lwowie. Czy może być lepsza data urodzenia dla matematyka niż 14 marca? Właśnie w tym dniu w 1882 roku w Warszawie urodził się nasz bohater. Na studia trafił na Cesarski Uniwersytet Warszawski, gdzie pod opieką Gieorgija Woronoja (tak, to ten Woronoj od Diagramu Woronoja) zainteresował się teorią liczb, obronił tytuł kandydata nauk (odpowiednik dzisiejszego magistra) i zaczął uczyć matematyki w gimnazjum. Nie pracował tam długo. Jako bardzo aktywna osoba brał udział w strajkach szkolnych przez co stracił pracę. Przeniósł się więc do Krakowa a na Uniwersytecie Jagiellońskim szybko zrobił doktorat badając sumy szeregów \\(\\sum_{m^2+n^2 \\leq x}f(m^2+n^2)\\). Trzy lata później habilitował się już na Uniwersytecie Lwowskim. W tamtym okresie i przez resztę życia wiele podróżował po znakomitych ośrodkach matematycznych na całym świecie. Był świetnym organizatorem biorącym udział w wielu inicjatywach. Przykładowo w roku 1920 wspólnie z Zygmuntem Janiszewskim i Stefanem Mazurkiewiczem założyli “Fundamenta Mathematicae” – pierwsze na świecie czasopismo poświęcone logice matematycznej, teorii mnogości oraz ich zastosowaniom. Sierpiński szybko dał się poznać jako świetny i bardzo wszechstronny matematyk. Gdy w 1920 Jan Kowalewski tworzył oddział łamania sowieckich szyfrów zatrudnił on Wacława Sierpińskiego razem ze Stefanem Mazurkiewiczem i Stanisławem Leśniewskim, aby sprawniej odszyfrowywać sowieckie depesze. Oddział ten był na tyle efektywny, że później przypisywano mu znaczny wkład w sukces Wojska Polskiego podczas Cudu nad Wisłą. Sukcesy tego zespołu zbudowały podwaliny pod biuro szyfrów w Poznaniu, które dekadę później rozsławili łamacze Enigmy Marian Rejewski, Jerzy Różycki i Henryk Zygalski. Przez lata Wacław Sierpiński uczył studentów w gimnazjach, wykładał na uniwersytetach, ale też pisał podręczniki. Wielu wydań doczekał się bardzo znany podręcznik do arytmetyki i geometrii, który napisał razem ze Stefanem Banachem i Włodzimierzem Stożkiem. Z uwagi na działaność związaną z nauczaniem został prezesem Towarzystwa Nauczycieli Szkół Średnich i Wyższych. Był też promotorem doktoratów wielu wybitnych matematyków, np. Jerzego Spławy-Neymana (współtwórcy współczesnej statystyki), Ottona Nikodyma, Kazimierza Kuratowskiego (wiele wyników z teorii mnogości i miary) czy Alfreda Tarskiego (wybitnego logika). Mając tak liczne talenty, jego zainteresowania były głównie związane z prowadzeniem badań naukowych. Napisał łącznie 113 artykułów, nie sposób więc krótko streścić jego licznych wyników. Jego pasją było studiowanie nieskończoności, czy to w teorii liczb, analizie matematycznej, teorii mnogości czy topologii. W roku 1915 w wieku 33 lat podał sposób konstrukcji Trójkąta Sierpińskiego, jako nieskończonego ciągu pewnych operacji. Jest to dziś jeden z najpopularniejszych fraktali, choć samo słowo pojęcie fraktala wprowadził dopiero Benedykt Mandelbrot 60 lat później w 1975. Jego nagrobek można znaleźć na warszawskich Powązkach, a na nagrobku widnieje napis “Badacz nieskończoności”. 1.2 Witajcie fraktale! Beta i Bit spotykają Wacława Sierpińskiego podczas wykładu w Krakowie W bazgrołach znudzonego Bita Wacław Sierpiński dostrzegł arcyciekawą figurę To fascynujące, że powtarzanie w nieskończoność tych samych czynności może prowadzić to arcyciekawych figur - fraktali. Taką figurę może narysować każdy, wystarczy podstawowa znajomość programowania. Krok po kroku pokażemy jak skonstruować różne klasy fraktali. Znajomość podstaw algebry, prawdopodobieństwa lub topologii pozwala dokładniej zrozumieć skąd się te zaskakujące figury biorą. 1.2.1 Kurz Cantora Jedną z ciekawszych metod konstrukcji fraktali jest metoda ,,przez wygryzanie’’. Bierzemy pewną figurę a następnie usuwamy z niej (wygryzamy) kawałki. To co zostaje jest fraktalem, często o zaskakujących właściwościach. Zilustrujmy to na przykładzie fraktalu nazywanego kurzem Cantora. Receptura na konstrukcje kurzu Cantora jest prosta: Weź odcinek o dowolnej długości (ale dla uproszczenia nasz będzie miał długość 1). Podziel ten odcinek na trzy równe części. Usuń wnętrze środkowej części, przez co otrzymasz dwa odcinki, oba o długości 1/3 wyjściowego odcinka. Dla każdego z otrzymanych odcinków kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 1. Rysunek 1: Pierwsze 5 iteracji w konstrukcji kurzu Cantora Powyższy algorytm ma kilka elementów typowych dla fraktali. Po pierwsze nigdy się nie kończy, całą procedurę należy (przynajmniej w teorii) powtarzać nieskończenie wiele razy. Po drugie, mamy do czynienia z rekurencją, pewien krok prowadzi do powstania zbioru obiektów a następnie każdy z tych obiektów jest ponownie przekształcany w ten sam sposób. W bardzo podobny sposób można otrzymać wiele ciekawych fraktali, ale przyjrzyjmy się jeszcze przez chwilę kurzowi Cantora. Zobaczmy co my właściwie otrzymaliśmy w wyniku tej procedury. Sprawdźmy może jak duży jest ten obiekt lub jaką ma długość. Początkowo odcinek miał długość \\(1\\), ale w pierwszym kroku usunęliśmy \\(1/3\\). W drugim kroku usunęliśmy \\(2\\) razy po \\((1/3)^2\\). Powtarzając to kilkukrotnie w kroku \\(k\\) usuwamy \\(2^{k-1}\\) odcinków, każdy o długości \\((1/3)^k\\). A więc długość tego tworu w kroku \\(k\\) to \\[ 1 - 1/3 - 2*(1/3)^2 - ... - 2^{k-1}*(1/3)^k = 1 - \\sum_{i=1}^k 2^{k-1}*(1/3)^k = 1 - 1/2 \\sum_{i=1}^k (2/3)^k = 0 \\] Do tego samego wniosku można dojść stosując inne rozumowanie, a mianowicie patrząc, ile zostało po \\(k\\) kroku. Po pierwszym kroku mamy \\(2\\) odcinki długości \\(1/3\\), po drugim kroku mamy \\(2^2\\) odcinków długości \\((1/3)^2\\) a po \\(k\\) kroku mamy \\(2^k\\) odcinków o długości \\((1/3)^k\\). Do czego zbiega ten szereg? \\[ \\lim_{k \\rightarrow \\infty} (2/3)^k = 0 \\] Nie ma więc wątpliwości, zbiór Cantora ma długość równą \\(0\\). Ale ewidentnie nie jest zbiorem pustym, bo ma wiele punktów. Jak wiele? Okazuje się, że tyle samo co cały odcinek, a więc nieprzeliczalnie wiele. Pokażmy to za pomocą pewnego sprytnego dowodu. Twierdzenie: Zbiór Cantora jest równoliczny z odcinkiem [0-1). Dowód: Aby policzyć punkty w zbiorze Cantora, potrzebujemy dla każdego punktu skonstruować rodowód, a więc zapis pozwalający jednoznacznie zidentyfikować każdy punkt. Rodowodem jednoznacznie identyfikującym punkt nazwiemy zbiór decyzji, określających jak do tego punktu dotrzeć w kolejnych krokach procedury generującej kurz Cantora. Pamiętamy, że w każdym kroku usuwane są środku z odcinków, więc punkt, który należy do kurzu będzie leżał albo w lewym albo w prawym odcinku. Ten wybór (lewy/prawy) trzeba podjąć w każdym kroku konstrukcji kurzu. Taki rodowód możemy zapisać przez nieskończoną sekwencje cyfr 0/1, jeżeli w sekwencji na pozycji k występuje 0 to punkt należy do lewego pododcinka, jeżeli 1 to do prawego. Zauważmy, jednoznaczność -&gt; każdy punkt z kurzu Cantora może być opisany przez nieskończoną sekwencje cyfr 0/1. Jednocześnie każda nieskończona sekwencja cyfr opisuje jakiś punkt ze zbioru Cantora, a różne sekwencje opisują różne punkty. Ile jest takich sekwencji? Kontinuum. Wystarczy bowiem myśleć o tych sekwencjach jak o rozwinięciach dwójkowych liczb z przedziału [0,1]. Co więc mamy? Kurz Cantora ma tyle samo punktów co odcinek [0,1]. Ale jednocześnie ma długość 0, choć odcinek ma oczywiście długość 1. Jak to możliwe? To jedna z wielu zagadek kryjących się w krainie fraktali malowanych nieskończonością. 1.2.2 Trójkąt Sierpińskiego Jeden z najbardziej znanych fraktali to trójkąt Sierpińskiego. Receptura na konstrukcje tego trójkąt jest dosyć podobna do kurzu Cantora. Oto dokładny przepis: Weź trójkąt równoboczny o dowolnej wielkości (ale dla uproszczenia nasz trójkąt będzie miał długość boku 1). Podziel ten trójkąt na cztery równe trójkąty równoboczne. Usuń środkowy trójkąt, przez co otrzymasz trzy trójkąty, oba o wielkości boku 1/2 wyjściowego trójkąta Dla każdego z otrzymanych trójkątów kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 2. Rysunek 2: Pierwsze cztery iteracje w konstrukcji trójkąta Sierpińskiego Ładny to twór. Ale jakie ma właściwości? Jakie jest jego pole? Tutaj już szybkie rachunki pozwalają rozwiać wszelkie wątpliwości. W kroku \\(k\\) trójkąt składa się z \\(3^k\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli polu \\(\\sqrt{3}/2^{2k+1}\\), czyli o łącznym polu \\((3/4)^k*\\sqrt{3}/2\\). W granicy mamy więc \\[ \\lim_{k \\rightarrow \\infty} (3/4)^k*\\sqrt{3}/2 = 0 \\] Więc trójkąt Sierpińskiego jest tak dziurawy, że ma pole równe 0. A jak długi jest jego brzeg? W kroku \\(k\\) brzeg zwiększa się o \\(3^{k-1}\\) trójkątów, każdy o boku \\((1/2)^k\\), czyli obwodzie \\(3*(1/2)^k\\). Czyli łaczny brzeg w kroku \\(k\\) to \\[ \\sum_{i=1}^k 3^{k-1}*3*(1/2)^k = \\sum_{i=1}^k (3/2)^k. \\] Elementy tego szeregu rosną do nieskończoności, więc tym bardziej cały obwód też eksploduje do nieskończoności. \\[ \\lim_{k \\rightarrow \\infty}\\sum_{i=1}^k (3/2)^k = \\infty \\] Co to za figura, jest ograniczona bo się mieści w trójkącie o boku 1, ale ma nieskończony obwód przy zerowym polu. Z jakiego to jest wymiaru? 1.2.3 Wymiar Hausdorfa Prawdopodobnie do tego miejsca część czytelników zadaje sobie pytanie czym są fraktale. Czy to takie dziwne obrazki? A jeżeli tak to jak je scharakteryzować? Jedną z częściej powtarzanych definicji fraktali jest definicja podana przez Mandelbrota, którą sparafrazuję do: Fraktalem nazywamy taki zbiór, którego wymiar Hausdorfa nie jest liczbą całkowitą. Ok, a czym jest ten wymiar Hausdorfa? Gdy myślimy o przestrzeniach Euklidesowych wymiarem określano liczbę ortogonalnych kierunków/wektorów rozpinających daną przestrzeń. I tak punkt ma wymiar 0, prosta ma wymiar 1, płaszczyzna ma wymiar 2, wszyscy doświadczamy trójwymiarowej przestrzeni. Czasem pewne obiekty możemy opisywać też w przestrzeniach o wyższych wymiarach i nie ma tu żadnych ograniczeń. Matematyk z podekscytowaniem w głosie może opowiadać o przestrzeni funkcji, która jest nieskończenie wymiarowa. Wymiar Hausdorfa określa się dla obiektów geometrycznych zanurzonych w zwykłych \\(p\\)-wymiarowych przestrzeniach (my ograniczymy się praktycznie wyłącznie do \\(p=2\\)). Aby go wyznaczyć, musimy policzyć iloma \\(p\\) wymiarowymi kostkami o boku \\(\\varepsilon\\) można przykryć interesujący nas obiekt. Jeżeli przez \\(N(\\varepsilon)\\) określimy minimalną liczbę kostek pokrywających obiekt \\(F\\) to wymiarem Hausdorfa \\(d_F\\) tego obiektu jest \\[ d_F = \\lim_{\\varepsilon \\rightarrow 0} \\frac{\\log N(\\varepsilon)}{\\log 1/\\varepsilon} \\] Przyjmijmy na razie, że interesują nas kostki o boku \\(\\varepsilon = 2^{-k}\\). Jeżeli chcemy przykryć nimi kwadrat o boku \\(1\\) to potrzebujemy ich przynajmniej \\(N(\\varepsilon) = 2^k * 2^k = 2^{2k}\\). Więc wymiar Hausdorfa kwadratu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{2k}}{\\log 1/2^{-k}} = 2 \\] A co z trójkątem Sierpińskiego? Tutaj wystarczy nam \\(N(\\varepsilon) = 3^k\\) kostek o boku \\(2^{-k}\\), a więc wymiar Hausdorfa dla tego trójkąta to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 3^{k}}{\\log 1/2^{-k}} = \\frac{\\log 3}{\\log 2} = 1,5849... \\] Rysunek 3 ilustruje jak wygląda przykładowe pokrycie trójkąta Sierpińskiego takimi kostkami. Rysunek 3: Pokrycie trójkąta Sierpińskiego kostkmi o boku 1/4 (lewy panel) i 1/8 (prawy panel) A jak to wygląda dla kurzu Cantora? Tym razem mamy obiekt zanurzony w przestrzeni jednowymiarowej, więc będziemy go przykrywać odcinkami. Przyjmijmy, że mamy odcinki o długości \\(\\varepsilon = 3^{-k}\\), aby pokryć cały kurz Cantora wystarczy nam takich odcinków \\(N(\\varepsilon) = 2^k\\), czyli wymiar Hausdorfa dla kurzu Cantora \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 2^{k}}{\\log 1/3^{-k}} = \\frac{\\log 2}{\\log 3} = 0,6309... \\] Wymiar mniejszy niż 1? To nic nadzwyczajnego w świecie fraktali. 1.2.4 Dywan Sierpińskiego Receptura na konstrukcje dywanu Sierpińskiego jest podobna do trójkąta. Oto dokładny przepis: Weź kwadrat o dowolnej wielkości (ale dla uproszczenia nasz kwadrat będzie miał długość boku 1). Podziel ten kwadrat na dziewięć równych kwadratów. Usuń środkowy kwadrat, przez co otrzymasz osiem kwadratów o wielkości boku 1/3 wyjściowego kwadratu. Dla każdego z otrzymanych kwadrat kontynuuj dzielenie idąc do kroku 2. Ilustracja czterech kolejnych kroków algorytmu wygryzania znajduje się na Rysunku 4. Rysunek 4: Pierwsze cztery iteracje w konstrukcji dywanu Sierpińskiego Jaki jest wymiar Hausdorfa tego tworu? Weźmy kostki o wielkości \\(\\varepsilon = 3^{-k}\\). Do zakrycia dywanu wystarczy nam \\(N(\\varepsilon) = 8^k\\) kostek o boku \\(3^{-k}\\). Więc wymiar Hausdorfa dla tego dywanu to \\[ d_F = \\lim_{k \\rightarrow \\infty} \\frac{\\log 8^{k}}{\\log 1/3^{-k}} = \\frac{\\log 8}{\\log 3} = 1,8927... \\] 1.3 Przykłady w Python W tym rozdziale przedstawiamy przykłady kodu w programie Python, które pozwalają na narysowanie kolejnych przybliżeń Kurzu Cantora, Trójkąta Sierpińskiego i Dywanu Sierpińskiego. Każdy może te fraktale odtworzyć na swoim komputerze, wystarczy tylko zainstalowany interpreter języka Python. Nie jest niezbędna wcześniejsza znajomość tego języka, choć oczywiście byłaby przydatna. Poniżej kilka informacji, które pomogą w zrozumieniu tego kodu. Poniższe przykłady korzystają z biblioteki matplotlib w której znajdują się funkcje do rysowania. Używana jest funkcja plot() do rysowania odcinka oraz fill() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. Funkcja figure() tworzy pusty wykres a show() powoduje, że wykres jest wyświetlany na ekranie komputera. Czasem potrzebne są funkcje matematyczne, np. by policzyć wysokość trójkąta równobocznego \\(\\sqrt3/2\\). Do takich operacji wykorzystujemy bibliotekę math. Aby skrócić zapis operacji dodawania lub mnożenia na dwuelementowych wektorach (współrzędnych punktów) stosowana jest biblioteka numpy. Aby kod był bardziej czytelny korzystamy z rekurencji, a więc funkcji, które same się wywołują. Nowe funkcje definiuje się z użyciem słowa kluczowego def. Każda funkcja może mieć argumenty, w poniższych przykładach używamy ich by określać gdzie rysować fraktale i jak duże. 1.3.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od Kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x czyli miejsce od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje odcinek, jeżeli depth&gt;1 to rysujemy dwa kurze Cantora obok siebie. # wczytujemy niezbędne biblioteki import matplotlib.pyplot as plt import numpy as np # definiujemy nową funkcje # kurz Cantora o boku scale i głębokości depth def dust(x, scale, depth): if depth &gt; 1: dust(x, scale / 3, depth - 1) dust(x + scale*2/3, scale / 3, depth - 1) else: plt.plot([x, x+scale], [0,0], color = &quot;black&quot;) # zaczynamy rysowanie fraktala # inicjacja rysunku i narysowanie kurzu o głębokości 5 plt.figure() dust(0, scale = 1, depth = 5) plt.show() Kurz Cantora o głębokości 5 1.3.2 Trójkąt Sierpińskiego Czas na kultowy Trójkąt Sierpińskiego. Aby go narysować wykorzystamy rekurencyjną funkcję sierpinski, która przyjmuje trzy argumenty: x czyli miejsce od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje trójkąt używając funkcji triangle(), jeżeli depth&gt;1 to rysujemy trzy trójkąty obok siebie. Trójkąt równoboczny jest rysowany funkcją triangle. # wczytujemy niezbędne biblioteki import matplotlib.pyplot as plt import numpy as np import math # rysuj trójkąt o boku scale zaczepiony w x def triangle(x, scale): plt.fill([x[0], x[0]+scale, x[0]+scale/2], [x[1], x[1], x[1]+scale*math.sqrt(3)/2], color = &quot;black&quot;) # rysuj trojkat Sierpinskiego o boku scale i głębokości depth zaczepiony w x def sierpinski(x, scale, depth): if depth &gt; 1: sierpinski(x, scale / 2, depth - 1) sierpinski(np.add(x, [scale/2, 0]), scale / 2, depth - 1) sierpinski(np.add(x, [scale/4, scale*math.sqrt(3)/4]), scale / 2, depth - 1) else: triangle(x, scale) # zaczynamy rysowanie fraktala # inicjacja rysunku i narysowanie trójkąta Sierpińskiego o głębokości 4 plt.figure() sierpinski([0,0], scale = 1, depth = 4) plt.show() Trójkąt Sierpińskiego o głębokości 4 1.3.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów, np. dla kwadratu lub pięcioboku. Poniżej jest przykład dla kwadratu. Aby go narysować wykorzystamy rekurencyjną funkcję carpet, która przyjmuje trzy argumenty: x czyli miejsce od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje kwadrat używając funkcji square(), jeżeli depth&gt;1 to rysujemy osiem fraktali obok siebie. import matplotlib.pyplot as plt import numpy as np def square(x, scale): plt.fill(np.add(x[0], [0, scale, scale, 0]), np.add(x[1], [0, 0, scale, scale]), color = &quot;black&quot;) # dywan Sierpinskiego o boku scale i głębokości depth def carpet(x, scale, depth): if depth &gt; 1: carpet(x, scale / 3, depth - 1) carpet(np.add(x, [scale/3, 0]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, 0]), scale / 3, depth - 1) carpet(np.add(x, [0, scale/3]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, scale/3]), scale / 3, depth - 1) carpet(np.add(x, [0, 2*scale/3]), scale / 3, depth - 1) carpet(np.add(x, [scale/3, 2*scale/3]), scale / 3, depth - 1) carpet(np.add(x, [2*scale/3, 2*scale/3]), scale / 3, depth - 1) else: square(x, scale) # zaczynamy rysowanie fraktala # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure() carpet([0,0], scale = 1, depth = 4) plt.show() Dywan Sierpińskiego o głębokości 4 1.4 Przykłady w R W tym rozdziale przedstawiamy przykłady kodu w programie R, które pozwalają na narysowanie kolejnych przybliżeń Kurzu Cantora, Trójkąta Sierpińskiego i Dywanu Sierpińskiego. Każdy może te fraktale odtworzyć na swoim komputerze, wystarczy tylko zainstalowany interpreter języka R, który można bezpłatnie pobrać i zainstalować ze strony https://cran.r-project.org/. Nie jest niezbędna wcześniejsza znajomość tego języka, choć oczywiście byłaby przydatna. Poniżej kilka informacji, które pomogą w zrozumieniu tego kodu. Poniższe przykłady korzystają z podstawowej biblioteki graficznej dla R, czyli graphics. Nie trzeba jej wczytywać, ponieważ jest dostępna od razu po wczytaniu R. Funkajc plot.new() wtorzy pusty wykres. Jest on wypełniany przez użycie funkcji polygon() do rysowania wypełnionych wielokątów, tutaj trójkąta i kwadratu. Wyniki wywołania kolejnych funkcji są od razu widoczne na ekranie komputera. R to język dla matematyków i statystyków, więc większość operacji matematycznych jest dostępna od razu po uruchomieniu konsoli. W szczególności funkcja sqrt() potrzebna do wyliczenia wysokości trójkąta równobocznego. Program R działa natywnie na wektorach, co znaczy, że możemy używać arytmetycznych operatorów takich jak + czy / zarówno dla liczb jak i dla wektorów. Nie jest wymagana do tego żadna dodatkowa biblioteka, w R wszystko jest traktowane jako wektor. Aby kod był bardziej czytelny korzystamy z rekurencji, a więc funkcji, które same się wywołują. Nowe funkcje definiuje się z użyciem słowa kluczowego function. Każda funkcja może mieć argumenty, w poniższych przykładach używamy ich by określać gdzie rysować fraktale i jak duże. W R można przypisywać wartości na dwa sposoby, korzystając operatora = lub &lt;-. Początkujących często dziwi zapis &lt;-, ale doświadczone osoby doceniają jego zalety, jak np. łatwość w odróżnieniu definiowania argumentów funkcji od przypisania wartości do symbolu. Poniżej będziemy stosowąc zapis z &lt;-. 1.4.1 Kurz Cantora Rysowanie fraktali rozpocznijmy od Kurzu Cantora. Wykorzystamy do tego rekurencyjną funkcję dust, która przyjmuje trzy argumenty: x czyli miejsce od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje odcinek, jeżeli depth&gt;1 to rysujemy dwa kurze Cantora obok siebie. dust &lt;- function(x, y, scale, depth = 1) { if (depth == 0) { lines(c(x, x + scale), c(y, y)) } else { dust(x, y, scale/3, depth - 1) dust(x + scale*2/3, y, scale/3, depth - 1) } } # czyścimy ekran i rysujemy fraktal plot.new() dust(0, 0, scale = 1, depth = 4) 1.4.2 Trójkąt Sierpińskiego Czas na kultowy Trójkąt Sierpińskiego. Aby go narysować wykorzystamy rekurencyjną funkcję sierpinski(), która przyjmuje trzy argumenty: x czyli miejsce od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje trójkąt używając funkcji triangle(), jeżeli depth&gt;1 to rysujemy trzy trójkąty obok siebie. Trójkąt równoboczny jest rysowany funkcją triangle. triangle &lt;- function(x, y, scale) { polygon(x + scale*c(0, 1, 1/2), y + scale*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } sierpinski &lt;- function(x, y, scale, depth = 1) { if (depth == 0) { triangle(x, y, scale) } else { sierpinski(x, y, scale/2, depth - 1) sierpinski(x+scale/2, y, scale/2, depth - 1) sierpinski(x+scale/4, y+sqrt(3)*scale/4, scale/2, depth - 1) } } # czyścimy ekran i rysujemy fraktal plot.new() sierpinski(0, 0, scale = 1, depth = 6) 1.4.3 Dywan Sierpińskiego Konstrukcja fraktala zaproponowana przez Wacława Sierpińskiego może być powtórzona dla innych kształtów, np. dla kwadratu lub pięcioboku. Poniżej jest przykład dla kwadratu. Aby go narysować wykorzystamy rekurencyjną funkcję carpet, która przyjmuje cztery argumenty: x i y czyli współrzędne punktu od którego należy rysować fraktal, scale czyli informacje o wielkości fraktalu oraz depth określającą aktualny poziom zagnieżdżenia fraktala. Jeżeli depth=1 to rysuje kwadrat używając funkcji rect(), jeżeli depth&gt;1 to rysujemy osiem fraktali obok siebie. carpet &lt;- function(x, y, scale, depth = 1) { if (depth == 1) { rect(x, y, x + scale, y + scale, col = &quot;black&quot;) } else { carpet(x, y, scale/3, depth - 1) carpet(x+scale*1/3, y, scale/3, depth - 1) carpet(x+scale*2/3, y, scale/3, depth - 1) carpet(x, y+scale*1/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*1/3, scale/3, depth - 1) carpet(x, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*1/3, y+scale*2/3, scale/3, depth - 1) carpet(x+scale*2/3, y+scale*2/3, scale/3, depth - 1) } } # czyścimy ekran i rysujemy fraktal plot.new() carpet(0, 0, scale = 1, depth = 4) "],["misja-druga.html", "Rozdział 2 Misja druga 2.1 Stefan Banach 2.2 Fraktal, czyli punkt stały 2.3 Przykłady w Python", " Rozdział 2 Misja druga Misja, w której chcąc nie chcąc dowiadujemy się czym jest kontrakcja, a także poznajemy wiele innych matematycznych obiektów. 2.1 Stefan Banach W 1892 roku, w Krakowie, urodził się jeden z najwybitniejszych matematyków XX wieku, genialny samouk, człowiek legenda, Stefan Banach. Matematyką interesował się już w gimnazjum, ale traktował ją raczej jako hobby. Seria przypadków zdecydowała o tym, że stał się czołowym reprezentantem Lwowskiej Szkoły Matematycznej. W szkole średniej Banach zaprzyjaźnił się z Witoldem Wilkoszem, późniejszym profesorem matematyki na Uniwersytecie Jagielońskim, z którym rozmawiał o rozmaitych matematycznych zagadkach. Później do tego grona dołączył Otto Nikodym i to właśnie jedna z rozmów o matematyce pomiędzy Banachem a Nikodymem doprowadziła do spotkania z Hugonem Steinhausem. Steinhaus dostrzegł olbrzymi talent matematyczny młodego Banacha, stworzył mu warunki do rozwoju, które szybko doprowadziły do rozwoju jednego z najbardziej twórczych, oryginalnych umysłów matematycznych. W 1920 roku, dzięki staraniom Hugona Steinhausa, Banach otrzymał posadę asystenta na Politechnice Lwowskiej u Antoniego Łomnickiego. Talent matematyczny i ciężka praca szybko przyniosły owoce. Po dwóch latach w pracy doktorskiej Banach zawarł nowe, dziś podstawowe twierdzenia analizy funkcjonalnej, rodzącej się dyscypliny matematyki. Jednym z wyników było zdefiniowanie “przestrzeni B”, która dzisiaj jest nazywana przestrzenią Banacha. O życiu Banacha krąży wiele anegdot. Jedna z nich dotyczy uzyskania stopnia doktora. Zgodnie z anegdotą, Banach na tyle nie dbał o formalne tytuły, że nie zamierzał starać się o doktorat. Jego przełożeni widząc talent matematyka i uważając, że stopień doktora jest potrzebny, uknuli intrygę. Rozprawę doktorską złożyli z luźnych notatek z twierdzeniami a na egzamin doktorski ściągnęli go podstępem, mówiąc, że z Warszawy przyjechała delegacja, która ma kilka ciekawych problemów matematycznych i trzeba im wytłumaczyć rozwiązania. W rzeczywistości Banach skończył normalne studia doktorskie, ale jego lekceważący stosunek do tytułów był świetną pożywką dla tego typu anegdot. Tak błyskotliwy umysł przyciągał inne błyskotliwe umysły. Jeszcze w 1919 Banach współtworzył Towarzystwo Matematyczne w Krakowie, które później przekształciło się w Polskie Towarzystwo Matematyczne. Już we Lwowie, razem ze Steinhausem założyli Lwowską Szkołę Matematyczną, która specjalizowała się w analizie funkcjonalnej. Była to kuźnia niesamowitych talentów, dość wymienić kilku jej przedstawicieli: współtwórca bomby termojądrowej i algorytmu Monte Carlo Stanisław Ulam, Władysław Orlicz badający przestrzenie funkcyjne, Mark Kac pracujący nad rachunkiem prawdopodobieństwa czy Stanisław Mazur rozwijający teorie przestrzeni liniowo-topologicznych. Ulubionym miejscem pracy Stefana Banacha była Kawiarnia Szkocka, gdzie przy kawie, koniaku czy muzyce spotykał się z innymi matematykami by pracować nad fascynującymi ich problemami. Problemy te były początkowo spisywane na serwetkach lub stole, do czasu, gdy Łucja, żona Banacha, wyposażyła grupę w gruby zeszyt. Ten zeszyt to legendarna Księga Szkocka. Co trudniejsze problemy miały zapisy o nagrodzie za ich rozwiązanie. Nagrody były równie oryginalne jak i cała szkoła Lwowska. Dość powiedzieć, że jedną z nagród była żywa gęś. Do dziś nie wszystkie problemy z tej księgi znalazły rozwiązanie. Nazwisko Banacha znajduje się w wielu matematycznych twierdzeniach czy innych niesamowitych wynikach. Jednym z nich jest paradoks Banacha-Tarskiego, twierdzenie mówiące, że można trójwymiarową kulę rozciąć na skończoną liczbę części, z których po odpowiednim obrocie i przesunięciu można złożyć dwie kule o takim samym rozmiarze. Niesamowicie pomysłowa konstrukcja, pozornie niemożliwa. Jak z obrotami dwukrotnie powiększyć objętość kuli? Okazuje się, że wystarczy by podzbiory były niemierzalne i już można robić z nimi matematyczne cuda. Życie Banacha pełne jest niesamowitych zwrotów akcji. Przed drugą wojną światową był uznanym profesorem matematyki. Pewnego dnia przyjechał do Lwowa John von Neumann by sprowadzić Banacha do Stanów. Miał wręczyć Banachowi czek z wpisaną cyfrą 1, oraz oświadczyć, że ten może dopisać tyle zer ile uzna za stosowne. Na to Banach miał odpowiedzieć, że “to za mało by wyjechać z Polski”. Ale wojna pozbawiła go i wielu innych badaczy możliwości pracy zarobkowej. Część wojny spędził jako karmiciel wszy w Instytucie Badań nad Tyfusem u profesora Rudolfa Weigla. Nie jest to praca marzeń, ale pozwalała na uniknięcie części represji stosowanych przez okupantów. Steinhaus powiedział kiedyś o Banachu, że “łączył w sobie iskrę geniuszu z jakimś zadziwiającym imperatywem wewnętrznym, który mu mówił bezustannie słowami poety ,,Jest tylko jedno: żarliwa gloria rzemiosła’’ - a matematycy wiedzą dobrze, że ich rzemiosło polega na tej samej tajemnicy, co rzemiosło poetów…”. 2.2 Fraktal, czyli punkt stały Beta i Bit spotykają Stefana Banacha w Kawiarni Szkockiej we Lwowie Stefan Banach w marudzeniu znudzonego Bita odnajduje ciekawe twierdzenie Gwoździem programu w tym rozdziale będzie twierdzenie Banacha o punkcie stałem i związek tego twierdzenia z fraktalami. Zaczniemy od pokazania konstrukcji kilku nowych ciekawych fraktali takich jak Smok Heighwaya czyi Paproć Barnsleya. Zaspokoiwszy pierwszą ciekawość związaną ze sposobem konstrukcji fraktali zagłębimy się w podstawy matematyczne tych figur Dla osób, które studiowały matematykę, może być to przypomnienie pewnych pojęć kluczowych w analizie matematycznej czy topologii. Dla osób, które matematyki nie studiowały, może być to interesujące spojrzenie na to jak matematycy formułują tezy. 2.2.1 Smoki i paprocie Pierwszy rozdział zostawił nas z metodą konstrukcji trzech rodzajów fraktali. Każdy z nich można było wykonać przez powtarzanie w kółko kroków: Algorytm na proste fraktale weź jakąś figurę, skopjuj ją \\(x\\)-razy, pomniejsz ją \\(y\\) razy, pomniejszone kopie poprzesuwaj, idź do kroku 2. W przypadku kurzu Kantora kopiowaliśmy \\(x=2\\) razy a pomniejszaliśmy \\(y=3\\) razy. Dla trójkąta Sierpińskiego kopiowaliśmy \\(x=3\\) razy a pomniejszaliśmy \\(y=2\\) razy. Dla Dywanu Sierpińskiego kopiowaliśmy \\(x=8\\) razy a pomniejszaliśmy \\(y=3\\) razy. Okazuje się, że w bardzo podobny sposób można stworzyć więcej różnych fraktali. A jeżeli obok skalowania i przesuwania pozwolimy jeszcze na obroty, to otrzymamy bardzo bogatą klasę różnorodnych ciekawych figur. Złożenie skalowania, przesuwania i obrotu nazwiemy przekształceniem afinicznym, ale dopiero w drugiej czesci tego rozdziału. Co więcej okazuje się, że figura wybrana w kroku 1 nie ma znaczenia! Jak później pokażemy, tym algorytmem dojdziemy do takiej samej figury bez względu na to czy na początku wykorzystamy rysunek trójkąta czy słonia czy małej kropki. Jak to możliwe! To będzie główny wniosek z twierdzenia Banacha o punkcie stałym. 2.2.1.1 Pięciokąt Sierpińskiego Zacznijmy od Pięciokątu Sierpińskiego (z ang. Pentagon Sierpinskiego). Sztuczkę z trójkątem czy kwadratem możemy powtórzyć z każdym wielokątem foremnym, np. pięciokątem. Jeżeli będziemy wyjściową figurę kopiować pięciokrotnie, następnie zmniejszać ją o 0.382 (a dokładniej o \\(\\frac{3-\\sqrt 5}2\\), patrz https://larryriddle.agnesscott.org/ifs/pentagon/details.htm), a następnie przesuwać w rogi pięciokąta, tak by zmniejszone figury stykały się krawędziamy, to po powtarzając tę procedurę wielokrotnie uzyskamy Pięciokąt Sierpińskiego. Dokłądnie taki jak na rysunku poniżej. Pięciokąt Sierpińskiego. Figura jest pomniejszana i przesuwana w pięć rogów pięciokąta, każdą z pięciu replikacji oznaczono innym kolorem. n-kąty Sierpinskiego. Tę samą sztuczkę można wykonać dla dowolnego n-kąta foremnego. Parametry skalowania i przesunięcia znaleźć można np. w Wikipedii https://en.wikipedia.org/wiki/N-flake Ale prawdziwa magia zaczyna się gdy w tych transformacjach pozwolimy na obroty. Algorytm konstrukcji złożonych fraktali weź jakąś figurę, skopjuj ją \\(x\\)-razy, pomniejsz ją \\(y\\) razy, pomniejszone kopie obróć i/lub przesuń, idź do kroku 2. Zobaczmy jak ten algorytm działa na przykałdzie kilku ciekawych zestawów transformacji. 2.2.1.2 Drzewo Pitagorasa Konstrukcja tego fraktala została opisana w 1942 roku przez Alberta Bosmana https://pl.wikipedia.org/wiki/Drzewo_pitagorejskie. Jest kilka różnych konstrukcji tej figury, poniżej przedstawimy konstrukcje opartą o dwie transformacje, które po złożeniu i odpowiednio długim powtarzaniu doprowadzą do drzewa. Transforamcja 1: obróć figurę o \\(45^{\\circ}\\) w lewo a następnie przeskalują ją współczynnikiem \\(\\sqrt(1/2)\\). Transforamcja 2: obróć figurę o \\(45^{\\circ}\\) w prawo a następnie przeskalują ją współczynnikiem \\(\\sqrt(1/2)\\). Poniższy obrazek ilustruje drzewo i obie transformacje. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Drzewo Pitagorasa. Panel A przedstawia fraktal, panel B ilustruje dwie transformacje składające się na fraktal. Obraz jest zmniejszany sqrt(2) razy i obracany o 45 stopni, każdą z dwóch replikacji oznaczono innym kolorem. 2.2.1.3 Smok Heighwaya Okazuje się, że bardzo wiele ciekawych figur można uzyskać dwoma transformacjami. Jedną z nich jest Smok Heighwaya którego konstrukcję pokazali po raz pierwszy John Heighway, Bruce Banks i William Harter z NASA. Oparta jest o takie dwie transformacje. Transformacja 1: obróć figurę o \\(45^{\\circ}\\) w lewo a następnie przeskalują ją współczynnikiem \\(\\sqrt(1/2)\\). Transformacja 2: obróć figurę o \\(45^{\\circ}\\) w lewo a następnie przeskalują ją współczynnikiem \\(\\sqrt(1/2)\\) i przesuń o 1 wzdłuż osi poziomej. Poniższy obrazek ilustruje smoka i obie transformacje. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Smok Heighwaya. Panel A przedstawia fraktal, panel B ilustruje dwie transformacje składające się na fraktal. Obraz jest zmniejszany obracany. Każdą z dwóch replikacji oznaczono innym kolorem. 2.2.1.4 Paproć Bernseya Dwiema transformacjami można uzyskać bardzo wiele, ale spróbujmy skonstruować jednej z najpopularniejszych fraktali - paproć Bernseya. Została ona po raz pierwszy opisana w 1993 przez Michaela Barnsleya. Będziemy do niej potrzebowali czterech transformacji. Transformacja 1: obróć figurę o \\(10^{\\circ}\\) w lewo a następnie przeskalują ją współczynnikiem \\((0.5, 0.3)\\). Transformacja 2: obróć figurę o \\(15^{\\circ}\\) w prawo a następnie przeskalują ją współczynnikiem \\((0.45, 0.25)\\). Transformacja 3: obróć figurę o \\(1^{\\circ}\\) w prawo a następnie przeskalują ją współczynnikiem \\(0.9\\) i przesuń o \\(0.01\\) wzdłuż osi X. Transformacja 4: obróć figurę o \\(1^{\\circ}\\) w lewo a następnie przeskalują ją współczynnikiem \\((0.25, 0.01)\\). Poniższy obrazek ilustruje paproć i wszystkie cztery transformacje. Kod pozwalający na odtworzenie tego fraktala znajduje się na końcu rozdziału. Paproć Bernseya. Panel A przedstawia fraktal, panel B ilustruje cztery transformacje składające się na fraktal. Obraz jest zmniejszany obracany. Każdą z czterech replikacji oznaczono innym kolorem. 2.2.2 Ale dlaczego to działa? Pokazane figury mają bardzo ciekawy opis matematyczny. Przedstawimy go poniżej na poziomie szczegółowości pierwszych lat studiów matematycznych. Najpierw zdefiniujemy kilka niezbędnych pojęć, w oparciu o które będzimey modeli podstawić twierdzenie o punkcie stałym. Zazwyczaj myśląc o figurach skupiamy się na bardzo klasycznej płaszczyźnie z dwoma osiami i zwykłą Euklidesową odległością. Ale na potrzeby zbliżającego się twierdzenia potrzebujemy spojrzeć na pewne rzeczy nieco bardziej ogólnie / abstrakcyjnie. 2.2.2.1 Przestrzeń metryczna W naszej historii bardzo ważną rolę będą odgrywały odległości pomiędzy punktami. Dlatego dalej w rozdziale często będziemy pisać o przestrzeni metrycznej. Co to takiego? Przestrzeń metryczna to zbiór \\(X\\) z określoną metryką (odległością) \\(d\\) pomiędzy punktami tego zbioru. Inaczej mówiąc, jeżeli pracujemy z przestrzenią metryczną to dla każdej pary punktów \\(a\\) i \\(b\\) potrafimy wyznaczyć ich odległość \\(d(a,b)\\). Odległość to funkcja spełniająca jednocześnie trzy warunki: \\(d(a,b) = 0 \\Leftrightarrow a = b\\), odległość wynosi zero wtedy i tylko wtedy gdy punkty są sobie równe, \\(d(a,b) = d(b,a)\\), odległość jest symetryczna, \\(d(a,b) \\leq = d(a,c) + d(c,b)\\), warunek trójkąta, czyli odległość pomiędzy dowolnymi dwoma punktami jest zawsze mniejsza równa niż suma odległości tych punktów od dowolnego innego punktu \\(c\\). Większość z nas (*) codziennym życiu najczęściej operuje w przestrzeni Euklidesową, ze zwykłą ,,linijkową’’ odległością. Ale aby pracować z fraktalami potrzebujemy bardziej wyrafinowanych linijek. (*) czytaj wszyscy, poza topologami. 2.2.2.2 Odległość Hausdorffa W świecie fraktali odległość pomiędzy punktami mierzy się bardzo przewrotnie - stosując odległość Hausdorffa. Ta odległość potrafi określić jak daleko od siebie są dwie figury (=zbiory punktów). Felix Hausdorff był niemieckim matematykiem, urodzonym we Wrocławiu w 1868. Zmarł w Bonn w 1942. Jego główny obszar zainteresował obejmował teorię mnogości i topologię. Mamy dwa zbiory punktów A i B w przestrzeni metrycznej z metryką \\(d\\) i chcemy określić jak daleko są od siebie. Intuicja za tą metryką jest następująca: zbiory są blisko siebie, jeżeli dla każdego punktu z jednego zbioru można znaleźć jakiś punkt z drugiego zbioru, który jest do niego bliski. Jeżeli każdy punkt ze zbioru \\(A\\) ma takiego ,,towarzysza’’ ze zbioru \\(B\\) to są one blisko. Spróbujmy to zapisać formalnie: \\[ d_H(A, B) = max \\left\\{ \\sup_{a\\in A} \\inf_{b\\in B} d(a, b); \\sup_{b \\in B} \\inf_{a \\in A} d(a, b) \\right\\}. \\] Zapis może przerazić, ale jeżeli rozłożyć go na części to okaże się bardzo intuicyjny. Cześć \\(\\inf_{b\\in B} d(a, b)\\) oznacza najmniejszą odległość od punktu \\(a\\) do dowolnego punktu ze zbioru \\(B\\). W takim razie \\(\\sup_{a\\in A} \\inf_{b\\in B} d(a, b)\\) to odległość najbardziej odstającego punktu ze zbioru \\(A\\). Odległość musi być symetryczna, więc we wzorze \\(d_H(A, B)\\) mamy maksimum z odstawiania zbioru \\(A\\) od \\(B\\) i odwrotnie. *Technicznie rzecz biorąc metryka Hausdorffa jest określona dla zwartych niepustych zbiorów. Można ją stosować też dla zbiorów domkniętych, ale wtedy może przyjmować wartości nieskończone. My będziemy pracować na zbiorach otwartych, ale można nie mówić tego na głos i pewnie wiele osób nawet nie zauważy różnicy. 2.2.2.3 Ciąg Cauchy’ego Drogi czytelniku, jak już pewnie zauważyłeś, konstruując fraktale powtarzamy pewne czynności w kółko. Tu i tam pojawia się sugestia, że należy to robić w nieskończoność. Zabawa w nieskończoność jest jednak ryzykowna, szczególnie, jeżeli nie mamy gwarancji, że gdzieś zbiegniemy. Skąd wziąć te gwarancje? Ciąg Cauchy’ego to ciąg punktów \\(a_n\\), w którym dla dowolnej większej od zera liczby \\(\\varepsilon\\) można znaleźć taki element ciągu \\(N\\), że wszystkie dalsze elementy są od odległości od siebie mniejszej niż \\(\\varepsilon\\). Formalnie zapiszemy to jako \\[ \\forall_{\\varepsilon &gt;0} \\exists_N \\forall_{m,n&gt;N} d(a_m,a_n) \\leq \\varepsilon \\] 2.2.2.4 Przestrzeń zupełna Ciągi zbieżne spełniają warunek Cauchy’ego, ale są też takie przestrzenie w których ciągi Cauchy’ego nie są zbieżne. To nie są porządne przestrzenie, więc dalej będziemy operować tylko na porządnych przestrzeniach, czyli przestrzeniach zupełnych. Przestrzeń metryczna \\((X,d)\\) jest zupełna jeżeli, każdy ciąg \\(a_n \\subset X\\) spełniający warunek Cauchy’ego jest zbieżny \\(X\\). I to są właśnie gwarancje których potrzebowaliśmy. 2.2.2.5 Kontrakcja Mamy porządą przestrzeń, teraz porozmawiajmy o transformacjach. Do konstrukcji fraktali możemy wykorzystywać specyfikaczne transformacje, które zbliżają punkty. Będziemy je nazywać kontrakcjami. Mówimy, że przekształcenie \\(T\\) jest przekształceniem zwężającym (kontrakcją), jeżeli istnieje stała \\(\\lambda \\in (0,1)\\) taka, że \\[ d(T(x), T(y)) \\leq \\lambda d(x,y). \\] Czyli dla dowolnych dwóch punktów \\(x\\) i \\(y\\) po przekształceniu są one bliżej niż przed. W przykładach o których rozmawialiśmy na początku rozdziału, każda pokazana transforamcja była kontrakcją. Dlaczego? Transformacje składały się z obrotów, przesunięć i skalowania. Obrót i przesunięcie nie zmienia odległości pomiędzy punktami, a wszystkie skalowania były wykonywane ze skalą mniejszą niż 1 dla każdej z osi. 2.2.2.6 Przekształcenie afiniczne Kontrakcje to bardzo szeroka klasa transformacji. My ograniczamy się do znaczeni węższej klasy transformacji liniowych z przesunięciami, czyli tzw. przekształceń afinicznych. Przekształcenie afiniczne to złożenie skalowania, obrotu i przesunięcia. Jeżeli skalowanie zmniejsza figurę to takie przekształcenie afiniczne jest kontrakcją, ponieważ obrót i przesunięcie nie zmienia odległości. Przekształcenia afiniczne można łatwo opisać w postaci algebraicznej, jako mnożenie punktu przez macierz przekształcenia. Pozwoli nam to skrócić zapis kodu, generującego fraktal. \\[ T_{rotate, \\alpha}(x) = \\begin{matrix} \\cos(\\alpha) &amp; -\\sin(\\alpha) \\\\ \\sin(\\alpha) &amp; \\cos(\\alpha) \\end{matrix} x \\] \\[ T_{scale, a, b}(x) = \\begin{matrix} a &amp; 0 \\\\ 0 &amp; b \\end{matrix} x \\] \\[ T_{shift, a, b}(x) = x + \\begin{matrix} a \\\\ b \\end{matrix} \\] Przekształcenia afiniczne możemy przedstawiać jako złożenie przesunięć, skalowania i obrotów lub, alternatywnie, jako operacja macierzowa opisana 6-cioma liczbami. W poniższym równaniu dla ułatwienia podano wymiary macierzy. \\[ [x&#39;\\ y&#39;]_{2\\times 1} = A_{2\\times 3} * [x\\ y\\ 1]_{3\\times 1} \\] W tym rozdziale będziemy głównie opierać się o opis przez złożenie skalowania, obrotu i przesunięcia. Ale w kolejnym rozdziale już wygodniej będzie nam pracować na operacjach macierzowych. 2.2.2.7 Twierdzenie Hutchinsona W tym miejscu ktoś powie, ok, każda z transformacji jestr kontrakcją, ale czy ich złożenie też musi być kontrakcją? Tak, dokładnie o tym mówi twierdzenie Hutchinsona Przekształcenie \\(T = T_1 \\cup T_2 \\cup ... \\cup T_k\\) jest zwężające, jeśli wszystkie przekształcenia \\(T_1, ..., T_k\\) użyte do zdefiniowania przekształcenia \\(T\\) są zwężające. Dowód tego twierdzenia nie jest długi, można go znaleźć np. w http://www.deltami.edu.pl/temat/matematyka/zastosowania/2011/06/26/Uklady_iterowanych_przeksztalcen/. 2.2.2.8 Twierdzenie Banacha o punkcie stałym Mamy już wszystko czego potrzebowaliśmy do pokazania twierdzenia Banach o punkcie stałym, czyli porządą przestrzeń, z porządną odległością w której używamy operatora \\(T\\), który jest kotrnacją. Precyzyjniej Jeśli \\((X, d)\\) jest przestrzenią metryczną zupełną, a \\(T: X\\to X\\) jest kontrakcją, to \\(T\\) ma dokładnie jeden punkt stały \\(x\\in X\\). Puntem stałym przekształcenia \\(T\\) jest taki punkt \\(x\\), że \\(T(x) = x\\). Dowód tego twierdzenia Banach przedstawił w swojej pracy doktorskiej. Nie jest on zbyt skomplikowany, mozna go znaleźć np. w http://www.deltami.edu.pl/temat/matematyka/zastosowania/2011/06/26/Uklady_iterowanych_przeksztalcen/. Tutaj ograniczymy się jedynie do pokazania jak szukać tego punktu stałego. Otóż okazuje się, że dla dowolnego punktu \\(x\\) przestrzeni \\(X\\) ciąg \\(T^n(x)\\) zbiega do punktu stałego. Gdzie \\(T^n(x)\\) oznacza n-krotne złożenie przekształcenia \\(T\\), czyli \\(T(T(T(...T(x)...)))\\). Czyli wystarczy w nieskończoność składać kontrakcje by znaleźć ich punkt stały. I takim punktem stałym są konstruowane przez nas fraktale. 2.3 Przykłady w Python Przykłady przedstawione w tym rozdziale powtarzają złożenie trzech atomowych transformacji - przesunięcia, przeskalowania i obrotu. Poniżej znajdują się definicje tych trzech transforamcji. W poniższych przykłądach x jest dwuelementowym wektorem. import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) 2.3.1 Trójkąt Sierpińskiego Trójkąt Sierpińskiego składa się z trzech transformacji. \\[ y_1 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] \\] \\[ y_2 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.5 \\\\ 0 \\end{smallmatrix}\\right] \\] \\[ y_3 = x * \\left[\\begin{smallmatrix} 0.5 &amp; 0\\\\ 0 &amp; 0.5 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.25 \\\\ \\sqrt3/4 \\end{smallmatrix}\\right] \\] Poniższy program powtarza złożenie tych funkcji depth razy. W teorii robilibyśmy to w nieskończoność, ale do wyraźnego obrazka wystarczy kilka kroków. Liczba punktów rośnie wykładniczo, więc po \\(k\\) krokach wynosi \\(3^k\\). import matplotlib.pyplot as plt import numpy as np # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # trojkat Sierpinskiego o głębokości depth def sierpinski(x, depth): if depth &gt; 1: x1 = scale(shift(x, [0, 0]), [0.5, 0.5]) sierpinski(x1, depth - 1) x2 = scale(shift(x, [0.5, 0]), [0.5, 0.5]) sierpinski(x2, depth - 1) x3 = scale(shift(x, [0.25, 0.5]), [0.5, 0.5]) sierpinski(x3, depth - 1) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = &quot;black&quot;, markersize=3) # inicjacja rysunku i narysowanie trójkąta Sierpińskiego plt.figure() sierpinski([0,0], depth = 7) plt.show() Trójkąt Sierpińskiego o głębokości 7 2.3.2 Spirala Aby zrobić spiralę, wystarczą nam dwie transformacje. Przesunięta miniatura \\[ y_1 = x * \\left[\\begin{smallmatrix} 0.4 &amp; 0\\\\ 0 &amp; 0.1 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 1 \\\\ 0 \\end{smallmatrix}\\right] \\] Obrócona spirala \\[ y_2 = x * \\left[\\begin{smallmatrix} \\cos(20^{\\circ}) &amp; -\\sin(20^{\\circ})\\\\ \\sin(20^{\\circ}) &amp; \\cos(20^{\\circ}) \\end{smallmatrix}\\right] * \\left[\\begin{smallmatrix} 0.9 &amp; 0\\\\ 0 &amp; 0.9 \\end{smallmatrix}\\right] \\] import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) # rysujemy spiralę def spiral(x,depth): if depth &gt; 1: x1 = scale(rotate(x, -math.pi * 20 / 180), [0.9, 0.9]) spiral(x1, depth - 1) x2 = shift(scale(x, [0.4, 0.4]), [1, 0]) spiral(x2, depth - 1) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = &quot;black&quot;, markersize=3) fig = plt.figure() spiral([0,0], depth = 14) plt.show() Spirala o głębokości 14 2.3.3 Paproć Uroszczona paproć składać się będzie z trzech transformacji. Lewy liść \\[ y_1 = x * \\left[\\begin{smallmatrix} \\cos(10^{\\circ}) &amp; -\\sin(10^{\\circ})\\\\ \\sin(10^{\\circ}) &amp; \\cos(10^{\\circ}) \\end{smallmatrix}\\right] * \\left[\\begin{smallmatrix} 0.3 &amp; 0\\\\ 0 &amp; 0.3 \\end{smallmatrix}\\right] \\] Prawy liść \\[ y_2 = x * \\left[\\begin{smallmatrix} \\cos(15^{\\circ}) &amp; \\sin(15^{\\circ})\\\\ -\\sin(15^{\\circ}) &amp; \\cos(15^{\\circ}) \\end{smallmatrix}\\right] * \\left[\\begin{smallmatrix} 0.25 &amp; 0\\\\ 0 &amp; 0.25 \\end{smallmatrix}\\right] \\] Łodyga \\[ y_3 = x * \\left[\\begin{smallmatrix} \\cos(1^{\\circ}) &amp; -\\sin(1^{\\circ})\\\\ \\sin(1^{\\circ}) &amp; \\cos(1^{\\circ}) \\end{smallmatrix}\\right] * \\left[\\begin{smallmatrix} 0.9 &amp; 0\\\\ 0 &amp; 0.9 \\end{smallmatrix}\\right] + \\left[\\begin{smallmatrix} 0.01 \\\\ 0 \\end{smallmatrix}\\right] \\] import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) # rysujemy paproć def fern(x,depth): if depth &gt; 1: x1 = shift(scale(rotate(x, -math.pi * 10 / 180), [0.3, 0.3]), [0, 0]) fern(x1, depth - 1) x2 = shift(scale(rotate(x, math.pi * 15 / 180), [0.25, 0.25]), [0, 0]) fern(x2, depth - 1) x3 = shift(scale(rotate(x, -math.pi * 1 / 180), [0.9, 0.9]), [0.01, 0]) fern(x3, depth - 1) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = &quot;black&quot;, markersize=3) fig = plt.figure() fern([0,0], depth = 11) plt.show() Paproć o głębokości 11 2.3.4 Pięciokąt Sierpińskiego Parametry transformacji pokazaliśmy na początku tego rozdziału. import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # rysujemy pentagon def pentagon(x,depth): if depth &gt; 1: x1 = shift(scale(x, [0.382, 0.382]), [0, 0]) pentagon(x1, depth - 1) x2 = shift(scale(x, [0.382, 0.382]), [0.618, 0]) pentagon(x2, depth - 1) x3 = shift(scale(x, [0.382, 0.382]), [0.809, 0.588]) pentagon(x3, depth - 1) x4 = shift(scale(x, [0.382, 0.382]), [0.309, 0.951]) pentagon(x4, depth - 1) x5 = shift(scale(x, [0.382, 0.382]), [-0.191, 0.588]) pentagon(x5, depth - 1) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = &quot;black&quot;, markersize=3) fig = plt.figure() pentagon([0,0], depth = 6) plt.show() Pentagon Sierpińskiego o głębokości 6 2.3.5 Smok Heighwaya Parametry transformacji pokazaliśmy na początku tego rozdziału. import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) t = 0.5 # rysujemy spiralę def heighway(x,depth,color = &quot;black&quot;): if depth &gt; 1: x1 = scale(rotate(x, -math.pi * 45 / 180), [math.sqrt(0.5), math.sqrt(0.5)]) heighway(x1, depth - 1, color = &quot;blue&quot;) x2 = shift(scale(rotate(x, -math.pi * (135 - 180*t) / 180), [math.sqrt(0.5), math.sqrt(0.5)]), [1 - 0.5*t, 0.5*t]) heighway(x2, depth - 1, color = &quot;red&quot;) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = color, markersize=3) fig = plt.figure() heighway([0,0], depth = 14) plt.show() Smok Heighwaya o głębokości 14 z parametrem t = 1 Smok Heighwaya o głębokości 14 z parametrem t = 0.5 2.3.6 Symetryczne drzewo binarne / drzewo Pitagorasa Odpowiednie transformacje zostały przedstawione na początku rozdziału. import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) r = 0.7 theta = 45 # rysujemy spiralę def sbt(x,depth,color = &quot;black&quot;): if depth &gt; 1: x1 = shift(scale(rotate(x, -math.pi * theta / 180), [r, r]), [0, 1]) sbt(x1, depth - 1, color = &quot;blue&quot;) x2 = shift(scale(rotate(x, math.pi * theta / 180), [r, r]), [0, 1]) sbt(x2, depth - 1, color = &quot;red&quot;) x3 = x sbt(x3, depth - 1, color = &quot;black&quot;) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = color, markersize=3) fig = plt.figure() sbt([0,0], depth = 14) plt.show() SBT o głębokości 14 2.3.7 McWorter’s Pentigree I jedna bonusowa figura https://larryriddle.agnesscott.org/ifs/pentigre/pentigre2.htm import math import numpy as np import matplotlib.pyplot as plt # przesunięcie punktu x o delta def shift(x, delta): return np.add(x, delta) # przeskalowanie punktu x razy ratio def scale(x, ratio): return np.multiply(x, ratio) # obrót wokół punktu 0,0 o kąt alpha def rotate(x, alpha): return np.matmul(x,[[math.cos(alpha), -math.sin(alpha)],[math.sin(alpha), math.cos(alpha)]]) # rysujemy pentigree def pentigree(x,depth, color = &quot;black&quot;): if depth &gt; 1: x1 = scale(rotate(x, math.pi * 36 / 180), [0.381966, 0.381966]) pentigree(x1, depth - 1, color=&quot;pink&quot;) x2 = shift(scale(rotate(x, math.pi * 108 / 180), [0.381966, 0.381966]), [0.309, 0.225]) pentigree(x2, depth - 1, color=&quot;orange&quot;) x3 = shift(scale(rotate(x, -math.pi * 36 / 180), [0.381966, 0.381966]), [0.191, 0.588]) pentigree(x3, depth - 1, color=&quot;black&quot;) x4 = shift(scale(rotate(x, -math.pi * 108 / 180), [0.381966, 0.381966]), [0.500, 0.363]) pentigree(x4, depth - 1, color=&quot;blue&quot;) x5 = shift(scale(rotate(x, -math.pi * 36 / 180), [0.381966, 0.381966]), [0.382, 0]) pentigree(x5, depth - 1, color=&quot;green&quot;) x6 = shift(scale(rotate(x, math.pi * 36 / 180), [0.381966, 0.381966]), [0.691, -0.225]) pentigree(x6, depth - 1, color=&quot;red&quot;) else: plt.plot(x[0],x[1], marker=&#39;o&#39;, color = color, markersize=3) fig = plt.figure() pentigree([0,0], depth = 6) plt.show() "],["misja-trzecia.html", "Rozdział 3 Misja trzecia 3.1 Hugo Steinhaus 3.2 Gra w Chaos 3.3 Przykłady w R 3.4 Przykłady w R 3.5 Przykłady w Python", " Rozdział 3 Misja trzecia Misja, w której odkrywamy, że czasem losowe działania prowadzą do przewidywalnych i niezmiennych wyników, a twierdzenia matematyczne potrafią mieć zaskakujące zastosowania. 3.1 Hugo Steinhaus Między duchem a materią pośredniczy matematyka Hugo Steinhaus urodził się w 1887 w Jaśle. Od dziecka był błyskotliwy, przejawiał olbrzymi talent do języków i nauk ścisłych. Rodzina chciała zrobić z niego inżyniera, ale jego bardziej pociągała matematyka. I dobrze, ponieważ to jeden z najpłodniejszych polskich matematyków. Dlaczego ludzie uczą się matematyki? Aby nauczać matematyki innych Po ukończeniu gimnazjum rozpoczął studia na Uniwersytecie Lwowskim. Podczas studiów przypadkiem poznał Stanisława Jolesa, który go namówił do przeniesienia się na Uniwersytet w Getyndze, która była wtedy najważniejszym ośrodkiem matematycznym w Europie. W Getyndze uczył się pod kierunkiem wybitnych matematyków, w tym Davida Hilberta i Felixa Kleina, poznał tam Wacława Sierpińskiego i obronił pracę doktorską. Po powrocie do Polski kontynuował badania naukowe to w Jaśle to w Krakowie z przerwą na służbę w wojsku podczas I wojny światowej. W roku 1916 dokonał swojego największego odkrycia naukowego (jego własne słowa) odkrył Stefana Banacha. Tak się złożyło, że Banach razem z Ottonem Nikodynem czekając na swojego przyjaciela Witolda Wilkosza rozmawiali o całkach Lebesgue’a. Zainteresowało to Steinhausa, który podzielił się z młodzieńcami problemem matematycznym nad którym akurat pracował. Ku jego zaskoczeniu, po kilku dniach Stefan Banach zgłosił się do niego z rozwiązaniem, które ostatecznie wspólnie opublikowali. Był to pierwszy artykuł Banacha i początek bardzo interesującej przyjaźni. Przyjaźni bardzo różnych osobowości, Banach lubił zabawę, nie dbał o konwenanse, Steinhaus był abstynentem, purystą językowym, zawsze pod krawatem. Jednak łączyła ich wspólna pasja i miłość do matematyki. Razem ze Steinhausem stworzyli Lwowską Szkołę Matematyczną, która w szczytowym momencie zrzeszała ponad 20 wybitnych matematyków. Matematyk zrobi to lepiej Jeszcze w Lwowie Steinhaus zachęcał studentów matematyki do zajmowania się zastosowaniami matematyki. Często powtarzając, że “Matematyk zrobi to lepiej” zachęcał studentów by mierzyli się z problemami z innych dziedzin, ponieważ często ścisły sposób myślenia pomaga w rozwiązywaniu najróżniejszych problemów. Sam dawał też świadectwo temu twierdzeniu. Chętnie współpracował z biologami, lekarzami, ekonomami i badaczami innych specjalizacji. Przykładowo, współpraca z Ludwikiem Hirszfeldem, doprowadziła do opracowania matematycznej teorii dochodzenia ojcostwa. We współpracy z dr Rozenzweigiem badał optymalną taryfę za energię elektryczną z perspektywy producenta energii. Wynalazł i opatentował introwizor – przyrząd do lokalizacji przedmiotów z użyciem promieniowania rentgenowskiego. Wynalazł Longimetr - proste urządzenie do oszacowania długości nieregularnych krzywych, które znalazło wiele zastosowań w geografii. We Wrocławiu pełnił funkcję kierownika działu zastosowań przyrodniczych i gospodarczych Instytutu Matematycznego PAN. Swoją pracownie nazwał “przychodnią matematyczną” do której każdy może się zgłosić ze swoimi “chorobami matematycznymi” po poradę. Szacuje się, że ponad połowa z jego ponad 200 artykułów dotyczy zastosowań matematyki. Geniusz - gen i już Steinhaus był też znanym aforystą. Wiele z jego aforyzmów, które nazywano hugonotkami, przeszły do historii. Można je było znaleźć między innymi w czasopiśmie Problemy w rubryce Cicer cum caule (łac. groch z kapustą) prowadzonej przez Juliana Tuwima. Legenda głosi, że gdy Tuwim pierwszy raz usłyszał aforyzm “Kula u nogi – Ziemia” uklęknął przed Steinhausem. Interesowała go też popularyzacja matematyki. Jeszcze w okresie międzywojennym napisał Kalejdoskop matematyczny, popularnonaukową książkę, mającą pokazać różne oblicza matematyki. Książka ta doczekała się wielu wydać i tłumaczeń. 3.2 Gra w Chaos Beta i Bit trafiają do Krakowa na Planty Rozmowa o całkach przyciąga zainteresowanych słuchaczy Stefana Banacha i Ottona Nikodyma a ich rozmowa przyciąga Hugona Steinhausa 3.3 Przykłady w R Pewną wadą rysowania fraktali w sposób opisany powyżej, jest wykładnicze tempo z jakim przybywa nowych obiektów. 8 iteracji to już jest dużo. Gdybyśmy chcieli wykonać 56 iteracji dla dywanu Sierpińskiego to musielibyśmy narysować \\(8^{56} &lt; 10^{50}\\) punktów, czyli więcej niż jest atomów na całej ziemi! Na szczęście jest też druga metoda rysowania fraktali, w której nie musimy używać rekurencji. Musimy za to dużo rysować, ale jak się okaże dzięki temu będziemy w stanie rysować fantastyczne inne fraktale. 3.3.1 Wylosuj mi transformacje Zademonstrujemy grę w chaos na przykładzie uszczelki Sierpińskiego. W poprzednim rozdziale, rysowaliśmy tą uszczelkę rysując trzy mniejsze uszczelki poprzesuwane w rogi trójkąta. Każda z tych uszczelek jest przekształceniem większej uszczelki. Co więcej to tak zwane przekształcenie zwężające (kontrakcja), czyli takie, które zmniejsza odległości pomiędzy punktami. W przypadku naszej uszczelki odległości zmniejszają się dwukrotnie, ale różne kontrakcje mogą mieć inne współczynniki zwężania, czasem nawet różne w różnych miejscach. Technicznie rzecz biorąc, uszczelka Sierpińskiego jest złożeniem trzech kontrakcji. Okazuje się, że ten sam obraz możemy otrzymać powtarzając taką sekwencję kroków: Wylosuj lub wybierz dowolny punkt startowy. Poniżej będzie to punkt (0,0), ale mógłby być też dowolny inny. Wylosuj jedną z kontrakcji, czyli jedno z trzech możliwych przekształceń w lewy, prawy lub górny róg. Przekształć punkt wylosowaną kontrakcją i narysuj wyznaczone współrzędne. Wróć do kroku 2. Powyższy algorytm należy powtórzyć nieskończoną liczbę razy, a jeżeli nam się spieszy to wystarczy zazwyczaj kilkadziesiąt tysięcy kroków. Spróbujmy! Poniżej zaczynamy z punktu (0,0), wykonamy 30 000 przekształceń. W każdym kroku za pomocą funkcji sample losujemy jedną z trzech przekształceń, które można zapisać matematycznie jako: \\(x&#39; = x/2\\), \\(y&#39; = y/2\\) (lewy róg) \\(x&#39; = x/2 + \\frac 12\\), \\(y&#39; = y/2\\) (prawy róg) \\(x&#39; = x/2 + \\frac 14\\), \\(y&#39; = y/2 + \\frac \\sqrt{3}2\\) (górny róg) A oto i kod N &lt;- 30000 x &lt;- 0 y &lt;- 0 # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,0.8), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:3, 1) switch(los, &#39;1&#39; = {x &lt;- x/2; y &lt;- y/2}, &#39;2&#39; = {x &lt;- x/2 + 1/2; y &lt;- y/2}, &#39;3&#39; = {x &lt;- x/2 + 1/4; y &lt;- y/2 + sqrt(3)/4}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } Oto i nasza uszczelka! 3.4 Przykłady w R Ok, czas to zapisać w R. Obiekt trans będzie listą czterech transformacji a prob będzie prawdopodobieństwem z jakim kolejne transformacje powinny być losowane. N = 50000 point &lt;- c(0, 0) # transformacje trans &lt;- list() trans[[1]] &lt;- matrix(c( 0.85, 0.04, 0, -0.04, 0.85, 1.6), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c(-0.15, 0.28, 0, 0.26, 0.24, 0.44), 2, 3, byrow = TRUE) trans[[3]] &lt;- matrix(c( 0.20, -0.26, 0, 0.23, 0.22, 1.6), 2, 3, byrow = TRUE) trans[[4]] &lt;- matrix(c( 0, 0, 0, 0, 0.16, 0), 2, 3, byrow = TRUE) prob = c(0.85, 0.07, 0.07, 0.01) # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 3.4.1 Smok Heighwaya Dobierając różne transformacje uzyskamy bardzo różne fraktale. Przykładowo Smok Heighwaya to złożenie dwóch transformacji \\(x&#39; = -0.4x -1\\), \\(y&#39; = -0.4y + 0.1\\) \\(x&#39; = 0.76x -0.4y\\), \\(y&#39; = 0.4x + 0.76y\\) A tutaj kod w R. Wystarczy zmienić opis transformacji a druga część kodu pozostaje bez zmian. N = 100000 point &lt;- c(0, 0) trans &lt;- list() trans[[1]] &lt;- matrix(c( -0.4, 0, -1, 0, -0.4, 0.1), 2, 3, byrow = TRUE) trans[[2]] &lt;- matrix(c( 0.76, -0.4, 0, 0.4, 0.76, 0), 2, 3, byrow = TRUE) prob = c(0.5, 0.5) # czyścimy ekran plot(0, xlim = c(-1.5,0.5), ylim = c(-1,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:length(trans), 1, prob = prob) point &lt;- trans[[los]] %*% c(point, 1) points(point[1], point[2], pch = &quot;.&quot;, col=&quot;black&quot;) } 3.4.2 Do It Yourself! Poszukaj i spróbuj zaimplementować inne fraktale, jak np: pentagon Sierpińskiego https://larryriddle.agnesscott.org/ifs/pentagon/pentagon.htm płatek Kocha https://larryriddle.agnesscott.org/ifs/ksnow/ksnow.htm McWorter’s Pentigree https://larryriddle.agnesscott.org/ifs/pentigre/pentigre2.htm Opisana powyżej metoda konstrukcji fraktali nazywa się systemem funkcji iterowanych (ang. iterated function system, IFS). Składane funkcje nie muszą być przekształceniami afinicznymi, wystarczy by były kontrakcjami. Eksperymentując z innymi przekształceniami można uzyskać bardzo ciekawe wyniki. 3.4.3 Paproć Barnsleya Gra w chaos jest bardzo wygodnym sposobem tworzenia fraktali. Możemy zwiększać liczbę kontrakcji, zmieniać ich współczynniki otrzymując bardzo ciekawe efekty. Jednym z bardziej znanych fraktali wzorowanych na obiektach botanicznych jest paproć Barnsleya. W stosunku do uszczelki wprowadzimy dwie modyfikacje. Będziemy mieli cztery kontrakcje, ale też będziemy losować je z różnymi prawdopodobieństwami. Gdybyśmy mieli nieskończenie wiele czasu, to ta druga zmiana nie byłaby potrzebna, ale dla skończonej liczby kroków odpowiednie dobrane prawdopodobieństwa pozwolą nam szybciej wysycić odpowiednie elementy paproci. Kontrakcje dla paproci Barnsleya. \\(x&#39; = 0.85x + 0.04y\\), \\(y&#39; = -0.04x + 0.85y + 1.6\\) (górna część paproci) \\(x&#39; = -0.15x + 0.28y\\), \\(y&#39; = 0.26x + 0.24y + 0.44\\) (lewy listek) \\(x&#39; = 0.20x - 0.26y\\), \\(y&#39; = 0.23x + 0.22y + 1.6\\) (prawy listek) \\(x&#39; = 0\\), \\(y&#39; = 0.16y\\) (łodyżka) Będziemy losować te kontrakcje w proporcjach 85:7:7:1. A tutaj mamy kod dla R! N = 50000 x = 0 y = 0 # czyścimy ekran plot(0, xlim = c(-2.5,3), ylim = c(0,12), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) for (i in 1:N) { los &lt;- sample(1:4, 1, prob = c(0.85, 0.07, 0.07, 0.01)) switch(los, &#39;1&#39; = {x &lt;- 0.85*x + 0.04*y; y &lt;- -0.04*x + 0.85*y + 1.6}, &#39;2&#39; = {x &lt;- -0.15*x + 0.28*y; y &lt;- 0.26*x + 0.24*y + 0.44}, &#39;3&#39; = {x &lt;- 0.20*x - 0.26*y; y &lt;- 0.23*x + 0.22*y + 1.6}, &#39;4&#39; = {x &lt;- 0; y &lt;- 0.16*y}) points(x, y, pch = &quot;.&quot;, col=&quot;black&quot;) } 3.5 Przykłady w Python 3.5.1 Paproć Barnsleya import numpy as np import matplotlib.pyplot as plt # transformacje składające się na paproć def trans1(x,y): return (0., 0.16*y) def trans2(x,y): return (0.85*x + 0.04*y, -0.04*x + 0.85*y + 1.6) def trans3(x,y): return (0.2*x - 0.26*y, 0.23*x + 0.22*y + 0.8) def trans4(x,y): return (-0.15*x + 0.28*y, 0.26*x + 0.24*y + 0.44) # lista funkcji transformations = [trans1,trans2,trans3,trans4] # prawdopodobieństwa wylosowania poszczególnych funkcji ps = [0.01, 0.79, 0.1, 0.1] # rozpocznij symulacje N = 200000 x, y = 0, 0 x_vec = [] y_vec = [] for i in range(N): transformation = np.random.choice(transformations, p=ps) x, y = transformation(x,y) x_vec.append(x) y_vec.append(y) plt.scatter(y_vec, x_vec, s=0.2, color=&quot;black&quot;) plt.show() Paproć składająca się z 200 000 punktów 3.5.2 Drzewo import numpy as np import matplotlib.pyplot as plt # transformacje składające się na drzewo def trans1(x,y): return(0.195*x -0.488*y + 0.4431, 0.344*x + 0.443*y + 0.2452) def trans2(x,y): return(0.462*x + 0.414*y + 0.2511, -0.252*x + 0.361*y + 0.5692) def trans3(x,y): return(-0.637*x + 0.8562, 0.501*y + 0.2512) def trans4(x,y): return(-0.035*x + 0.07*y + 0.4884, -0.469*x + 0.022*y + 0.5069) def trans5(x,y): return(-0.058*x -0.07*y + 0.5976, 0.453*x -0.111*y + 0.0969) # lista funkcji transformations = [trans1,trans2,trans3,trans4, trans5] # prawdopodobieństwa wylosowania poszczególnych funkcji ps = [0.2, 0.2, 0.2, 0.2, 0.2] # rozpocznij symulacje N = 200000 x, y = 0, 0 x_vec = [] y_vec = [] for i in range(N): transformation = np.random.choice(transformations, p=ps) x, y = transformation(x,y) x_vec.append(x) y_vec.append(y) plt.scatter(x_vec, y_vec, s=0.2, color=&quot;black&quot;) plt.show() Drzewo składające się z 200 000 punktów 3.5.3 Maple Leaf http://paulbourke.net/fractals/ifs/ import numpy as np import matplotlib.pyplot as plt def transform(x,y, affine): return(affine[0]*x + affine[1]*y + affine[2], affine[3]*x + affine[4]*y + affine[5]) # lista funkcji affines = [[0.14, 0.01, -0.08, 0.0, 0.51, -1.31], [0.43, 0.52, 1.49, -0.45, 0.5, -0.75], [0.45, -0.49, -1.62, 0.47, 0.47, -0.74], [0.49, 0.0, 0.02, 0.0, 0.51, 1.62]] # prawdopodobieństwa wylosowania poszczególnych funkcji ps = [0.25, 0.25, 0.25, 0.25] # rozpocznij symulacje N = 200000 x, y = 0, 0 x_vec = [] y_vec = [] for i in range(N): affine = affines[np.random.choice(range(0,4), p=ps)] x, y = transform(x,y, affine) x_vec.append(x) y_vec.append(y) plt.scatter(x_vec, y_vec, s=0.2, color=&quot;black&quot;) plt.show() Liść klonu składający się z 200 000 punktów 3.5.4 Spirala affines = [[0.787879, -0.424242, 1.758647, 0.242424, 0.859848, 1.408065], [-0.121212, 0.257576, -6.721654, 0.151515, 0.05303, 1.377236], [0.181818, -0.136364, 6.086107, 0.090909, 0.181818, 1.568035]] ps = [0.9, 0.05, 0.05] Spirala składająca się z 200 000 punktów 3.5.5 IFS Mandelbrot-like affines = [[0.202, -0.805, -0.373, -0.689, -0.342, -0.653], [0.138, 0.665, 0.66, -0.502, -0.222, -0.277]] ps = [0.5, 0.5, 0] Spirala składająca się z 200 000 punktów 3.5.6 IFS Tree affines = [[0.05, 0.0, -0.06, 0.0, 0.4, -0.47], [-0.05, 0.0, -0.06, 0.0, -0.4, -0.47], [0.03, -0.14, -0.16, 0.0, 0.26, -0.01], [-0.03, 0.14, -0.16, 0.0, -0.26, -0.01], [0.56, 0.44, 0.3, -0.37, 0.51, 0.15], [0.19, 0.07, -0.2, -0.1, 0.15, 0.28], [-0.33, -0.34, -0.54, -0.33, 0.34, 0.39]] ps = [1/7, 1/7, 1/7, 1/7, 1/7, 1/7, 1/7] Drzewo składająca się z 200 000 punktów 3.5.7 Gra w Chaos i trójkąt Wybierz trzy punkty -&gt; rogi trójkąta Wybierz dowolny inny punkt startowy Ileś razy powtórz: wylosuj wierzchołek przesuń punkt startowy o połowę w kierunku wylosowanego wierzchołka import math import numpy as np import matplotlib.pyplot as plt triangle = [[0,0], [1, 2], [2,1]] point = [0.1, 0] # rozpocznij symulacje N = 200000 x_vec = [] y_vec = [] for i in range(N): ind = np.random.choice(range(0,3)) point = np.add(triangle[ind], np.multiply(np.subtract(point, triangle[ind]), 0.5)) x_vec.append(point[0]) y_vec.append(point[1]) plt.scatter(x_vec, y_vec, s=0.2) plt.show() Trojkat w chaosie 100 000 punktów "],["podsumowanie.html", "Rozdział 4 Podsumowanie 4.1 Story 4.2 Wybrane fraktale", " Rozdział 4 Podsumowanie 4.1 Story Beta i Bit wracają do bazy 4.2 Wybrane fraktale http://www.algorytm.org/fraktale/system-funkcji-iterowanych-ifs.html 4.2.1 Trójkąt Sierpińskiego p1 = 0.3333 p2 = 0.3333 p3 = 0.3334 f1(0.5x + 0.0y - 0.5; 0.0x + 0.5y + 0.5) f2(0.5x + 0.0y - 0.5; 0.0x + 0.5y - 0.5) f3(0.5x + 0.0y + 0.5; 0.0x + 0.5y - 0.5) 4.2.2 Spirala p1 = 0.895652 p2 = 0.052174 p3 = 0.052174 f1(0.787879x - 0.424242y + 1.758647; 0.242424x + 0.859848y + 1.408065) f2(-0.121212x + 0.257576y - 6.721654; 0.151515x + 0.053030y + 1.377236) f3(0.181818x - 0.136364y + 6.086107; 0.090909x + 0.181818y + 1.568035) 4.2.3 Smok p1 = 0.787473 p2 = 0.212527 f1(0.824074x + 0.281428y - 1.882290; -0.212346x + 0.864198y - 0.110607) f2(0.088272x + 0.520988y + 0.785360; -0.463889x - 0.377778y + 8.095795) 4.2.4 Paproć Barnsley’a p1 = 0.01 p2 = 0.85 p3 = 0.07 p4 = 0.07 f1(0.0x + 0.0y + 0.0, 0.0x + 0.16y + 0.0) f2(0.85x + 0.04y + 0.0; -0.04x + 0.85y + 1.6) f3(0.2x - 0.26y + 0.0; 0.23x + 0.22y + 1.6) f4(-0.15x + 0.28y + 0.0; 0.26x + 0.24y + 0.44) 4.2.5 Liść klonu p1 = 0.1 p2 = 0.35 p3 = 0.35 p4 = 0.2 f1(0.14x + 0.01y - 1.31; 0.0x + 0.51y + 0.1) f2(0.43x + 0.52y + 1.49; -0.45x + 0.5y - 0.75) f3(0.45x - 0.49y - 1.62; 0.47x + 0.47y - 0.74) f4(0.49x + 0.0y + 0.02; 0.0x + 0.51y + 1.62) 4.2.6 Drzewo p1 = 0.142 p2 = 0.142 p3 = 0.142 p4 = 0.142 p5 = 0.142 p6 = 0.142 p7 = 0.142 f1(0.05x + 0.0y - 0.06; 0.0x + 0.4y - 0.47) f2(-0.05x + 0.0y - 0.06; 0.0x - 0.4y - 0.47) f3(0.03x - 0.14y - 0.16; 0.0x + 0.26y -0.01) f4(-0.03x + 0.14y - 0.16; 0.0x - 0.26y -0.01) f5(0.56x + 0.44y + 0.3; -0.37x + 0.51y + 0.15) f6(0.19x + 0.07y - 0.2; -0.1x + 0.15y + 0.28) f7(-0.33x - 0.34y - 0.54; -0.33x + 0.34y + 0.39) "],["zalaczniki.html", "Rozdział 5 Zalaczniki 5.1 Przykłady w Julia 5.2 Przykłady w R", " Rozdział 5 Zalaczniki 5.1 Przykłady w Julia using Plots function trojkat(x, y, bok) return [(x+bok*0,y+bok*0),(x+bok*1,y+bok*0),(x+bok*1/2,y+bok*sqrt(2)/2),(x+bok*0,y+bok*0)] end # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.plot!(trojkat(x, y, szerokosc), seriestype=:shape, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 2, y, szerokosc / 2, iteracja - 1) rysuj_uszczelke(x+szerokosc / 4, y+sqrt(3)*szerokosc/4, szerokosc / 2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 5) using Plots # czyścimy ekran E = 0.05 Plots.plot(0,xlim=(0-E,1+E),ylim=(0-E,1+E-0.1)) function rysuj_uszczelke(x, y, szerokosc, iteracja) if iteracja == 0 Plots.scatter!([x], [y], markerstrokecolor=:white, markersize=3, color=:black, legend=:false) else rysuj_uszczelke(x, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/2, y, szerokosc/2, iteracja - 1) rysuj_uszczelke(x+szerokosc/4, y+sqrt(3)*szerokosc/4, szerokosc/2, iteracja - 1) end current() end rysuj_uszczelke(0, 0, 1, 8) 5.2 Przykłady w R W programie R nie ma funkcji rysującej trójkąty, więc musimy ją najpierw zdefiniować. Do tego celu używamy funkcji polygon, która rysuje wypełnione zamknięte wielokąty. Na jej bazie definiujemy funkcje trojkat rysującą trójkąt równoboczny o boku bok zaczepiony lewym dolnym rogiem w punkcie (x, y). trojkat &lt;- function(x, y, bok) { polygon(x + bok*c(0, 1, 1/2), y + bok*c(0, 0, sqrt(3)/2), col = &quot;black&quot;) } Przetestujmy tę funkcję. Najpierw funkcją plot.new otworzymy nowy obszar do rysowania o wymiarach 1x1 a następnie narysujemy trójkąt o boku 1. plot.new() trojkat(0, 0, 1) Jeżeli chcielibyśmy narysować drugi krok konstrukcji trójkąta Sierpińskiego to musielibyśmy wywołać funkcję trojkat trzy razy. plot.new() trojkat(0, 0, 0.5) trojkat(0.5, 0, 0.5) trojkat(0.25, sqrt(3)/4, 0.5) Aby narysować trzeci krok należałoby wywołać tę funkcję \\(3^2\\) razy. plot.new() trojkat(0, 0, 0.25) trojkat(0.25, 0, 0.25) trojkat(0.125,sqrt(3)/8, 0.25) trojkat(0.5, 0, 0.25) trojkat(0.75, 0, 0.25) trojkat(0.625, sqrt(3)/8, 0.25) trojkat(0.25, sqrt(3)/4, 0.25) trojkat(0.50, sqrt(3)/4, 0.25) trojkat(0.375,3*sqrt(3)/8, 0.25) Rysowanie kolejnych kroków kopiując linijki z funkcją trojkat byłoby niepraktyczne. Znacznie lepiej wykorzystać rekurencje. Poniżej tworzymy funkcje fraktal_trojkat, która w kroku 0 rysuje w trójkąt o zadanym boku a w innych krokach wywoluje się z poleceniem narysowani trzech miejszych fraktali o boku będącym połową wyjściowego. fraktal_trojkat &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { trojkat(x, y, bok) } else { fraktal_trojkat(x, y, bok/2, krok - 1) fraktal_trojkat(x+bok/2, y, bok/2, krok - 1) fraktal_trojkat(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } Wypróbujmy ją! Może na początek ustawmy 5 iteracji, przez co narysujemy \\(3^5 = 243\\) trójkątów. plot.new() fraktal_trojkat(0, 0, bok = 1, krok = 5) Bardzo bardzo mały trójkąt wygląda jak punkt Zamiast rysować trójkąt wystarczy narysować jeden punkt, bo trójkąty po pewnym czasie i tak są strasznie małe. Tyle, że trójkąt Sierpińskiego składająca się z \\(243\\) punktów jest dosyć dziurawa. Dlatego sprawdzimy jak wygląda dla 8 iteracji. plot.new() fraktal_punkt &lt;- function(x, y, bok, krok = 0) { if (krok == 0) { points(x, y, pch=&quot;.&quot;, col=&quot;black&quot;) } else { fraktal_punkt(x, y, bok/2, krok - 1) fraktal_punkt(x+bok/2, y, bok/2, krok - 1) fraktal_punkt(x+bok/4, y+sqrt(3)*bok/4, bok/2, krok - 1) } } fraktal_punkt(0, 0, bok = 1, krok = 8) Ile punktów narysowaliśmy? 5.2.1 Dywan Sierpińskiego w R Prace z fraktalami rozpoczniemy od utkania Dywanu Sierpińskiego. Zaczniemy od jego zubożonej wersji, którą trochę łatwiej opisać na początku, a później pokażemy przepis na kompletny dywan. Jest to dobry fraktal na początek, wystarczy: narysować kwadrat pomniejszyć rysunek 3 razy skopiować 4 razy w cztery rogi kwadratu z otrzymanym rysunkiem wrócić do kroku 2 i tak w nieskończoność. Pierwsze trzy iteracje powyższego schematu przedstawione są na rysunku poniżej. images/fraktale_01.png Ok, spróbujmy to zrobić w R. 5.2.1.1 Narysuj mi kwadrat Zacznijmy od narysowania kwadratu. Pierwsza linijka poniższego przykładu tworzy pusty obszar do rysowania o wymiarach [0,1]x[0,1]. Druga linijka zawiera instrukcje rect(), która rysuje czarny kwadrat rozpięty od punktu (0,0) do (1,1). # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1, 1, col = &quot;black&quot;) W drugiej iteracji ten kwadrat jest trzykrotnie pomniejszany do wymiarów 1/3 x 1/3 i rysowany w czterech rogach. Mamy do narysowania cztery kwadraty i możemy to zrobić w poniższy sposób. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/3, 1/3, col = &quot;black&quot;) rect(0+2/3, 0, 1/3+2/3, 1/3, col = &quot;black&quot;) rect(0, 0+2/3, 1/3, 1/3+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/3+2/3, 1/3+2/3, col = &quot;black&quot;) W trzeciej iteracji w miejsce każdego z tych czterech kwadratów rysujemy kolejne 4 kwadraty trzykrotnie pomniejszone. W sumie będzie to 16 kwadratów, sporo ale jeszcze damy radę to zapisać. Można to zrobić tak # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rect(0, 0, 1/9, 1/9, col = &quot;black&quot;) rect(0+2/9, 0, 1/9+2/9, 1/9, col = &quot;black&quot;) rect(0, 0+2/9, 1/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/9, 1/9+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3, 0, 1/9+2/3, 1/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0, 1/9+2/3+2/9, 1/9, col = &quot;black&quot;) rect(0+2/3, 0+2/9, 1/9+2/3, 1/9+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/9, 1/9+2/3+2/9, 1/9+2/9, col = &quot;black&quot;) rect(0, 0+2/3, 1/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/9, 0+2/3, 1/9+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0, 0+2/3+2/9, 1/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/9, 0+2/3+2/9, 1/9+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3, 0+2/3, 1/9+2/3, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3, 1/9+2/3+2/9, 1/9+2/3, col = &quot;black&quot;) rect(0+2/3, 0+2/3+2/9, 1/9+2/3, 1/9+2/3+2/9, col = &quot;black&quot;) rect(0+2/3+2/9, 0+2/3+2/9, 1/9+2/3+2/9, 1/9+2/3+2/9, col = &quot;black&quot;) Aby narysować dywan sierpińskiego musimy tę procedurę powtórzyć przynajmniej kilka razy, co wymaga narysowania tysięcy, a często jeszcze większej liczby, kwadratów. Przy takiej liczbie kwadratów kopiowanie kolejnych linijek z wywołaniem funkcji rect nie ma sensu. 5.2.1.2 Rekurencja Zrobimy to sprytniej używając rekurencji, czyli funkcji, która sama siebie wywołuje. Skorzystamy z cechy, która nazywa się samopodobieństwem, czyli cały dywan jest podobny do swoich części. Poniższy przykład przedstawia bardzo sprytną funkcję rysuj_dywan(). Ma ona kilka ciekawych argumentów. Pierwsze dwa x i y wskazują w którym miejscu ma być rysowany dywan, trzeci szerokosc określa szerokość rysowanego dywanu, a ostatni iteracja określa ile iteracji powyższego algorytmu powinniśmy wykonać by narysować dywan. Jeżeli funkcja rysuj_dywan() zostanie wywołana z argumentem iteracja = 0 to narysuje sam kwadrat. Ale jeżeli zostanie wykonana z innym argumentem to narysuje cztery dywany zaczepione w rogach kwadratu o szerokości \\(1/3\\) wyjściowego dywanu. Zobaczmy co z tego wyjdzie! # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 2) Możemy teraz w prosty sposób narysować kolejne iteracje małym nakładem kodu. Na trzecim poziomie będzie to \\(4^3 = 64\\) kwadratów. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 3) Zobaczmy jak będzie ta figura wyglądała dla piątej iteracji. Mamy już do czynienia z \\(4^5 = 2^10 = 1024\\) kwadratami. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) 5.2.1.3 Prawdziwy dywan Widzimy już jak działa rekurencja oraz co się dzieje w kolejnych iteracjach. Jesteśmy gotowi do narysowania pełnego dywanu Sierpińskiego. Różnica jest taka, że w każdym kroku, zamiast czterech kwadratów w rogach, będziemy rysować 8 kwadratów ,,po obwodzie’’ dużego kwadratu. W poniższej funkcji w każdym kroku z iteracja różnym od 0, rysujemy 8 mniejszych dywanów. rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { rect(x, y, x + szerokosc, y + szerokosc, col = &quot;black&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } Rysowanie dywanu dla pięciu iteracji może trochę trwać, ponieważ składa się z \\(8^5 = 2^15 = 32768\\) kwadratów. Ale warto chwilę poczekać by uzyskać taki wynik. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Oczywiście możemy zwiększać liczbę iteracji, ale zmiany na obrazku przestają być zauważalne. 5.2.1.4 Bardzo bardzo mały kwadrat wygląda jak punkt Zauważmy, że narysowany kwadrat bardzo szybko maleje. Maleje wręcz z wykładniczą prędkością. Więc po wielu iteracjach nie musimy rysować kwadratu, wystarczy, że narysujemy punkt, mniej zachodu. Sprawdźmy czy tak faktycznie jest. Zmienimy funkcję rysuj_dywan() by w finalnej iteracji rysowała punkt. # czyścimy ekran plot(0, xlim = c(0,1), ylim = c(0,1), xlab=&quot;&quot;, ylab=&quot;&quot;, col=&quot;white&quot;) rysuj_dywan &lt;- function(x, y, szerokosc, iteracja = 0) { if (iteracja == 0) { points(x, y, col = &quot;black&quot;, pch=&quot;.&quot;) } else { rysuj_dywan(x, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*1/3, szerokosc/3, iteracja - 1) rysuj_dywan(x, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*1/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) rysuj_dywan(x+szerokosc*2/3, y+szerokosc*2/3, szerokosc/3, iteracja - 1) } } rysuj_dywan(0, 0, szerokosc = 1, iteracja = 5) Tada! Również otrzymujemy dywan, trochę bardziej dziurawy. W zależności od rozdzielczości ekranu warto zwiększyć liczbę iteracji do sześciu lub siedmiu, by dywan się ,,nasycił’’. "],["podziękowania.html", "Podziękowania", " Podziękowania Gdy już ta książka powstanie, należy napisać bez kogo by nie powstała. "],["bibliografia.html", "Bibliografia", " Bibliografia "]]
